#!/bin/bash
#
# Site Manager - 统一管理工具
# 用法: site [命令]
#

VERSION="2.0.0"
ROOT_DIR="/opt/site_manager"
PANEL_DIR="$ROOT_DIR/panel"
PANEL_BIN="$PANEL_DIR/site_manager_panel"
PANEL_CONFIG="$PANEL_DIR/config/config.json"
PANEL_DB="$PANEL_DIR/data/panel.db"

# 颜色
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
CYAN="\033[36m"
NC="\033[0m"

# 加载库文件
[ -f "$ROOT_DIR/lib/colors.sh" ] && source "$ROOT_DIR/lib/colors.sh"
[ -f "$ROOT_DIR/lib/utils.sh" ] && source "$ROOT_DIR/lib/utils.sh"
[ -f "$ROOT_DIR/config/site_manager.conf" ] && source "$ROOT_DIR/config/site_manager.conf"

NGINX_CONF_DIR="${NGINX_CONF_DIR:-/etc/nginx/sites-available}"
NGINX_ENABLED_DIR="${NGINX_ENABLED_DIR:-/etc/nginx/sites-enabled}"
SITES_DIR="${SITES_DIR:-/www/wwwroot}"
LOGS_DIR="${LOGS_DIR:-/www/wwwlogs}"

# 检查/创建 www 用户和组
ensure_www_user() {
    if ! getent group www >/dev/null 2>&1; then
        groupadd www || { echo -e "${RED}创建 www 组失败${NC}"; return 1; }
    fi
    if ! getent passwd www >/dev/null 2>&1; then
        useradd -g www -s /sbin/nologin -M www || { echo -e "${RED}创建 www 用户失败${NC}"; return 1; }
    fi
    return 0
}

# 验证域名格式
validate_domain() {
    local domain="$1"
    if [[ ! "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        echo -e "${RED}无效的域名格式: $domain${NC}"
        return 1
    fi
    return 0
}

# 获取 MySQL 连接参数
get_mysql_args() {
    local args=""
    if [ -n "$MYSQL_USER" ] && [ -n "$MYSQL_PASS" ]; then
        args="-u$MYSQL_USER -p$MYSQL_PASS"
    elif [ -f "${MYSQL_DEFAULTS_FILE:-/www/server/panel/data/default.pl}" ]; then
        local pass=$(cat "${MYSQL_DEFAULTS_FILE:-/www/server/panel/data/default.pl}" 2>/dev/null)
        [ -n "$pass" ] && args="-uroot -p$pass"
    fi
    echo "$args"
}

# 执行 MySQL 命令 (带错误处理)
mysql_exec() {
    local args=$(get_mysql_args)
    mysql $args "$@" 2>/dev/null
}

# 执行 mysqldump (带错误处理)
mysqldump_exec() {
    local args=$(get_mysql_args)
    local db="$1"
    local output="$2"

    if ! mysqldump $args --single-transaction --quick "$db" > "$output" 2>/dev/null; then
        echo -e "${RED}备份失败: $db${NC}"
        rm -f "$output"
        return 1
    fi

    # 检查输出文件是否有效
    if [ ! -s "$output" ]; then
        echo -e "${RED}备份文件为空: $db${NC}"
        rm -f "$output"
        return 1
    fi

    return 0
}

# 安全的 nginx 配置测试和重载
nginx_safe_reload() {
    local rollback_files=("$@")

    if nginx -t 2>/dev/null; then
        systemctl reload nginx
        return 0
    else
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5

        # 回滚：删除刚创建的配置文件
        for f in "${rollback_files[@]}"; do
            [ -f "$f" ] && rm -f "$f"
            [ -L "$f" ] && rm -f "$f"
        done

        echo -e "${YELLOW}已回滚配置更改${NC}"
        return 1
    fi
}

# 自动检测已安装的 PHP-FPM 版本
detect_php_fpm() {
    local php_sock=""
    for v in 8.3 8.2 8.1 8.0 7.4; do
        if [[ -S "/run/php/php${v}-fpm.sock" ]]; then
            php_sock="/run/php/php${v}-fpm.sock"
            break
        fi
    done
    # 如果没找到，默认使用 8.3
    echo "${php_sock:-/run/php/php8.3-fpm.sock}"
}
PHP_FPM_SOCK=$(detect_php_fpm)

# 检查指定 PHP 版本是否已安装
check_php_installed() {
    local version="$1"  # 如 7.3, 8.0, 8.3
    [[ -S "/run/php/php${version}-fpm.sock" ]] && return 0
    command -v "php${version}" &>/dev/null && return 0
    return 1
}

# 安装指定 PHP 版本
install_php_version() {
    local version="$1"
    echo -e "${CYAN}正在安装 PHP ${version}...${NC}"
    
    # 添加 PHP 源 (如果不存在)
    if [[ ! -f /etc/apt/sources.list.d/php.list ]]; then
        curl -sSL https://packages.sury.org/php/apt.gpg | gpg --dearmor -o /usr/share/keyrings/php-archive-keyring.gpg 2>/dev/null
        echo "deb [signed-by=/usr/share/keyrings/php-archive-keyring.gpg] https://packages.sury.org/php/ $(lsb_release -sc) main" > /etc/apt/sources.list.d/php.list
        apt-get update -qq
    fi
    
    local extensions="fpm cli common mysql curl gd mbstring xml zip bcmath redis intl"
    local pkgs=""
    for ext in $extensions; do
        pkgs="$pkgs php${version}-${ext}"
    done
    
    apt-get install -y -qq $pkgs > /dev/null 2>&1 || { echo -e "${RED}PHP ${version} 安装失败${NC}"; return 1; }
    
    # 配置 PHP-FPM
    local fpm_conf="/etc/php/${version}/fpm/pool.d/www.conf"
    if [[ -f "$fpm_conf" ]]; then
        sed -i "s/^user = .*/user = www/" "$fpm_conf"
        sed -i "s/^group = .*/group = www/" "$fpm_conf"
        sed -i "s/^listen.owner = .*/listen.owner = www/" "$fpm_conf"
        sed -i "s/^listen.group = .*/listen.group = www/" "$fpm_conf"
    fi
    
    systemctl enable "php${version}-fpm" 2>/dev/null
    systemctl restart "php${version}-fpm"
    echo -e "${GREEN}PHP ${version} 安装完成${NC}"
    return 0
}

# 解析 PHP 类型参数 (php73 -> 7.3)
parse_php_version() {
    local type="$1"
    if [[ "$type" =~ ^php([0-9])([0-9]+)$ ]]; then
        echo "${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
    fi
}

# ================== 主菜单 ==================
show_menu() {
    clear
    echo ""
    echo -e "${GREEN}================ Site Manager v$VERSION ================${NC}"
    echo ""
    echo -e " 1) 站点管理              4) 安全管理"
    echo -e " 2) 软件管理              5) 系统信息"
    echo -e " 3) 备份管理              6) Web面板"
    echo ""
    echo -e " 0) 退出"
    echo -e "${GREEN}=======================================================${NC}"
    echo ""
}

# ================== 站点管理 ==================
site_menu() {
    echo ""
    echo -e "${CYAN}======== 站点管理 ========${NC}"
    echo " 1) 查看所有站点"
    echo " 2) 创建站点"
    echo " 3) 删除站点"
    echo " 4) 启用站点"
    echo " 5) 禁用站点"
    echo " 6) 申请SSL证书"
    echo " 7) 续期SSL证书"
    echo " 8) 站点详情"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) site_list;;
        2) site_create;;
        3) site_delete;;
        4) read -p "域名: " d; [ -n "$d" ] && site_enable "$d";;
        5) read -p "域名: " d; [ -n "$d" ] && site_disable "$d";;
        6) site_list; read -p "域名: " d; [ -n "$d" ] && ssl_request "$d";;
        7) ssl_renew;;
        8) read -p "域名: " d; [ -n "$d" ] && site_info "$d";;
    esac
}

site_list() {
    echo ""
    printf "%-30s %-12s %-10s\n" "域名" "类型" "状态"
    printf "%-30s %-12s %-10s\n" "----" "----" "----"
    for conf in "$NGINX_CONF_DIR"/*; do
        [ -f "$conf" ] || continue
        local name=$(basename "$conf")
        [[ "$name" == "default" || "$name" == *.bak ]] && continue
        local domain="${name%.conf}"
        local type="static"
        local php_ver=""
        # 检测类型和 PHP 版本
        if grep -q "fastcgi_pass" "$conf"; then
            php_ver=$(grep -oP "php\K[0-9]+\.[0-9]+" "$conf" | head -1)
            type="php${php_ver:+ $php_ver}"
        elif grep -q "proxy_pass" "$conf"; then
            type="proxy"
        fi
        local status="disabled"
        [ -L "$NGINX_ENABLED_DIR/$domain" ] || [ -L "$NGINX_ENABLED_DIR/$name" ] && status="${GREEN}enabled${NC}"
        printf "%-30s %-12s %-10b\n" "$domain" "$type" "$status"
    done
    echo ""
}

site_create() {
    read -p "域名: " domain
    [ -z "$domain" ] && echo -e "${RED}域名不能为空${NC}" && return
    
    echo -e " ${CYAN}选择站点类型:${NC}"
    echo " 1) PHP 8.3    4) PHP 7.4"
    echo " 2) PHP 8.1    5) 静态站点"
    echo " 3) PHP 8.0    6) 反向代理"
    read -p "类型 [1]: " t
    
    local type="" php_version=""
    case "$t" in
        1|"") type="php"; php_version="8.3";;
        2) type="php"; php_version="8.1";;
        3) type="php"; php_version="8.0";;
        4) type="php"; php_version="7.4";;
        5) type="static";;
        6) type="proxy";;
        *) type="php"; php_version="8.3";;
    esac

    _do_site_create "$domain" "$type" "$php_version"
}

# 实际创建站点的函数
_do_site_create() {
    local domain="$1"
    local type="$2"
    local php_version="$3"

    # 验证域名格式
    validate_domain "$domain" || return 1

    # 确保 www 用户存在
    ensure_www_user || return 1

    local site_path="$SITES_DIR/$domain"
    local conf_path="$NGINX_CONF_DIR/$domain"

    [ -f "$conf_path" ] && echo -e "${RED}站点已存在${NC}" && return 1

    # PHP 站点检查并安装
    if [[ "$type" == "php" && -n "$php_version" ]]; then
        if ! check_php_installed "$php_version"; then
            echo -e "${YELLOW}PHP $php_version 未安装，正在自动安装...${NC}"
            install_php_version "$php_version" || return 1
        fi
    fi

    # 创建目录
    if [ "$type" = "php" ]; then
        mkdir -p "$site_path/public"
        echo "<?php phpinfo();" > "$site_path/public/index.php"
        local root="$site_path/public"
    else
        mkdir -p "$site_path"
        echo "<h1>Welcome to $domain</h1>" > "$site_path/index.html"
        local root="$site_path"
    fi
    chown -R www:www "$site_path" && chmod -R 755 "$site_path" && find "$site_path" -type f -exec chmod 644 {} \;

    # 生成配置
    cat > "$conf_path" << NGINX
server {
    listen 80;
    server_name $domain;
    root $root;
    index index.php index.html;

    access_log $LOGS_DIR/${domain}_access.log;
    error_log $LOGS_DIR/${domain}_error.log;
NGINX

    if [ "$type" = "php" ]; then
        local php_sock="/run/php/php${php_version}-fpm.sock"
        cat >> "$conf_path" << NGINX

    location / {
        try_files \$uri \$uri/ /index.php?\$query_string;
    }

    location ~ \\.php\$ {
        fastcgi_pass unix:${php_sock};
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
        include fastcgi_params;
    }
}
NGINX
    elif [ "$type" = "proxy" ]; then
        read -p "代理目标 (如 http://127.0.0.1:3000): " target
        cat >> "$conf_path" << NGINX

    location / {
        proxy_pass $target;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
    }
}
NGINX
    else
        cat >> "$conf_path" << 'NGINX'

    location / {
        try_files $uri $uri/ /index.html;
    }
}
NGINX
    fi

    ln -sf "$conf_path" "$NGINX_ENABLED_DIR/$domain"

    # 安全测试并重载，失败时回滚
    if nginx_safe_reload "$conf_path" "$NGINX_ENABLED_DIR/$domain"; then
        echo -e "${GREEN}站点 $domain 创建成功 (${type}${php_version:+ $php_version})${NC}"
    else
        # 清理站点目录
        [ -d "$site_path" ] && rm -rf "$site_path"
        echo -e "${RED}站点创建失败${NC}"
        return 1
    fi
}
# 内部删除函数 - 可被 CLI 和交互式菜单调用
# 用法: _do_site_delete <域名> <模式> [--yes]
# 模式: config (仅配置), full (配置+文件), backup (备份后删除)
_do_site_delete() {
    local domain="$1"
    local mode="$2"
    local skip_confirm="$3"

    validate_domain "$domain" || return 1

    local conf_path="$NGINX_CONF_DIR/$domain"
    local enabled_path="$NGINX_ENABLED_DIR/$domain"
    local site_path="$SITES_DIR/$domain"

    [ ! -f "$conf_path" ] && echo -e "${RED}站点不存在: $domain${NC}" && return 1

    case "$mode" in
        config)
            # 仅删除配置
            rm -f "$enabled_path" "$conf_path"
            if nginx_safe_reload; then
                echo -e "${GREEN}配置已删除 (文件保留在 $site_path)${NC}"
            else
                echo -e "${RED}Nginx 重载失败，配置已删除但可能需要手动处理${NC}"
                return 1
            fi
            ;;
        full)
            # 删除配置和文件
            if [ "$skip_confirm" != "--yes" ]; then
                read -p "确认删除配置和所有文件? (输入 'yes' 确认): " confirm
                [ "$confirm" != "yes" ] && echo "已取消" && return 0
            fi
            rm -f "$enabled_path" "$conf_path"
            [ -d "$site_path" ] && rm -rf "$site_path"
            rm -f "$LOGS_DIR/${domain}_access.log" "$LOGS_DIR/${domain}_error.log"
            if nginx_safe_reload; then
                echo -e "${GREEN}站点已完全删除: $domain${NC}"
            else
                echo -e "${RED}Nginx 重载失败，但文件已删除${NC}"
                return 1
            fi
            ;;
        backup)
            # 备份后删除
            local backup_file="$BACKUP_DIR/${domain}_$(date +%Y%m%d_%H%M%S).tar.gz"
            mkdir -p "$BACKUP_DIR"
            echo "正在备份..."
            if [ -d "$site_path" ]; then
                if tar -czf "$backup_file" -C "$(dirname "$site_path")" "$(basename "$site_path")" 2>/dev/null; then
                    echo -e "${GREEN}备份成功: $backup_file${NC}"
                else
                    echo -e "${RED}备份失败，操作已取消${NC}"
                    return 1
                fi
            fi
            rm -f "$enabled_path" "$conf_path"
            [ -d "$site_path" ] && rm -rf "$site_path"
            rm -f "$LOGS_DIR/${domain}_access.log" "$LOGS_DIR/${domain}_error.log"
            if nginx_safe_reload; then
                echo -e "${GREEN}站点已删除: $domain${NC}"
            else
                echo -e "${RED}Nginx 重载失败，但备份和文件删除已完成${NC}"
                return 1
            fi
            ;;
        *)
            echo -e "${RED}无效模式: $mode (支持: config, full, backup)${NC}"
            return 1
            ;;
    esac
}

# 交互式删除 - 菜单调用
site_delete() {
    site_list
    read -p "域名: " domain
    [ -z "$domain" ] && return

    validate_domain "$domain" || return 1

    local conf_path="$NGINX_CONF_DIR/$domain"
    local site_path="$SITES_DIR/$domain"

    [ ! -f "$conf_path" ] && echo -e "${RED}站点不存在${NC}" && return

    echo ""
    echo -e "${YELLOW}即将删除站点: $domain${NC}"
    echo " 配置文件: $conf_path"
    [ -d "$site_path" ] && echo " 站点目录: $site_path ($(du -sh "$site_path" 2>/dev/null | cut -f1))"
    echo ""
    echo " 1) 仅删除配置 (保留文件)"
    echo " 2) 删除配置和站点文件"
    echo " 3) 备份后删除全部"
    echo " 0) 取消"
    read -p "选择: " choice

    case "$choice" in
        1) _do_site_delete "$domain" "config";;
        2) _do_site_delete "$domain" "full";;
        3) _do_site_delete "$domain" "backup";;
        *) echo "已取消";;
    esac
}

site_enable() {
    local domain="$1"

    # 验证域名格式
    validate_domain "$domain" || return 1

    # 检查配置文件是否存在
    if [ ! -f "$NGINX_CONF_DIR/$domain" ]; then
        echo -e "${RED}站点配置不存在: $NGINX_CONF_DIR/$domain${NC}"
        return 1
    fi

    # 创建符号链接
    ln -sf "$NGINX_CONF_DIR/$domain" "$NGINX_ENABLED_DIR/$domain"

    # 测试 nginx 配置
    if ! nginx -t 2>/dev/null; then
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5
        rm -f "$NGINX_ENABLED_DIR/$domain"
        echo -e "${YELLOW}已移除符号链接，请检查站点配置${NC}"
        return 1
    fi

    # 重载 nginx
    if systemctl reload nginx; then
        echo -e "${GREEN}$domain 已启用${NC}"
    else
        echo -e "${RED}Nginx 重载失败${NC}"
        rm -f "$NGINX_ENABLED_DIR/$domain"
        return 1
    fi
}

site_disable() {
    local domain="$1"
    local link_target=""

    # 验证域名格式
    validate_domain "$domain" || return 1

    # 检查符号链接是否存在
    if [ ! -L "$NGINX_ENABLED_DIR/$domain" ]; then
        echo -e "${YELLOW}站点未启用或链接不存在${NC}"
        return 0
    fi

    # 保存原链接目标以便回滚
    link_target=$(readlink -f "$NGINX_ENABLED_DIR/$domain" 2>/dev/null)

    # 移除符号链接
    rm -f "$NGINX_ENABLED_DIR/$domain"

    # 测试 nginx 配置
    if ! nginx -t 2>/dev/null; then
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5
        # 恢复符号链接
        if [ -n "$link_target" ] && [ -f "$link_target" ]; then
            ln -sf "$link_target" "$NGINX_ENABLED_DIR/$domain"
            echo -e "${YELLOW}已恢复符号链接，请检查 Nginx 配置${NC}"
        fi
        return 1
    fi

    # 重载 nginx
    if systemctl reload nginx; then
        echo -e "${GREEN}$domain 已禁用${NC}"
    else
        echo -e "${RED}Nginx 重载失败${NC}"
        # 恢复符号链接
        if [ -n "$link_target" ] && [ -f "$link_target" ]; then
            ln -sf "$link_target" "$NGINX_ENABLED_DIR/$domain"
        fi
        return 1
    fi
}

site_info() {
    local domain="$1"
    local conf="$NGINX_CONF_DIR/$domain"
    [ ! -f "$conf" ] && echo -e "${RED}站点不存在${NC}" && return
    echo ""
    echo -e "域名: $domain"
    echo -e "目录: $SITES_DIR/$domain"
    echo -e "大小: $(du -sh "$SITES_DIR/$domain" 2>/dev/null | awk '{print $1}')"
    echo -e "配置: $conf"
    grep -q "ssl_certificate" "$conf" && echo -e "SSL:  ${GREEN}已启用${NC}" || echo -e "SSL:  未配置"
    echo ""
}

# SSL 函数已移至 lib/ssl.sh

# ================== 软件管理 ==================
# ================== 软件管理 ==================
SOFTWARE_DIR="/opt/site_manager/software"
SOFTWARE_LIST="$SOFTWARE_DIR/list.json"

software_menu() {
    echo ""
    echo -e "${CYAN}======== 软件管理 ========${NC}"
    echo " 1) 查看已安装软件"
    echo " 2) 安装软件"
    echo " 3) 卸载软件"
    echo " 4) 服务管理"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) soft_list;;
        2) soft_install;;
        3) soft_uninstall;;
        4) service_menu;;
    esac
}

soft_list() {
    echo ""
    printf "%-12s %-10s %-10s %s\n" "软件" "版本" "状态" "描述"
    printf "%-12s %-10s %-10s %s\n" "----" "----" "----" "----"
    
    # 检查各软件状态
    local items=("nginx:/usr/sbin/nginx" "php:/usr/bin/php" "mysql:/usr/bin/mysql" "redis:/usr/bin/redis-server" "nodejs:/usr/bin/node" "docker:/usr/bin/docker" "composer:/usr/local/bin/composer")
    
    for item in "${items[@]}"; do
        local name="${item%%:*}"
        local check="${item##*:}"
        local version="-"
        local status="${RED}未安装${NC}"
        
        if [ -f "$check" ] || [ -x "$check" ]; then
            status="${GREEN}已安装${NC}"
            case "$name" in
                nginx) version=$(nginx -v 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                php) version=$(php -v 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                mysql) version=$(mysql --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1);;
                redis) version=$(redis-server --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                nodejs) version=$(node --version 2>/dev/null | tr -d 'v');;
                docker) version=$(docker --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                composer) version=$(composer --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
            esac
        fi
        printf "%-12s %-10s %-10b\n" "$name" "${version:-?}" "$status"
    done
    echo ""
}

soft_install() {
    echo ""
    echo -e "${CYAN}可安装的软件:${NC}"
    echo " 1) nginx    - Web服务器"
    echo " 2) php      - PHP语言"
    echo " 3) mysql    - MySQL数据库"
    echo " 4) redis    - Redis缓存"
    echo " 5) nodejs   - Node.js运行时"
    echo " 6) docker   - Docker容器"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    
    local script=""
    local version=""
    case "$c" in
        1) script="nginx.sh"; echo "可用版本: 1.24, 1.26, 1.27"; read -p "版本[1.26]: " version; version="${version:-1.26}";;
        2) script="php.sh"; echo "可用版本: 7.4, 8.0, 8.1, 8.2, 8.3"; read -p "版本[8.2]: " version; version="${version:-8.2}";;
        3) script="mysql.sh"; echo "可用版本: 5.7, 8.0, 8.4"; read -p "版本[8.0]: " version; version="${version:-8.0}";;
        4) script="redis.sh";;
        5) script="nodejs.sh"; echo "可用版本: 18, 20, 22"; read -p "版本[20]: " version; version="${version:-20}";;
        6) script="docker.sh";;
        0|*) return;;
    esac
    
    if [ -n "$script" ] && [ -f "$SOFTWARE_DIR/install/$script" ]; then
        bash "$SOFTWARE_DIR/install/$script" install "$version"
    else
        echo -e "${RED}安装脚本不存在${NC}"
    fi
}

soft_uninstall() {
    echo ""
    echo -e "${YELLOW}选择要卸载的软件:${NC}"
    echo " 1) nginx  2) php  3) mysql  4) redis  5) nodejs  6) docker"
    read -p "选择: " c
    
    local script=""
    case "$c" in
        1) script="nginx.sh";; 2) script="php.sh";; 3) script="mysql.sh";;
        4) script="redis.sh";; 5) script="nodejs.sh";; 6) script="docker.sh";;
        *) return;;
    esac
    
    if [ -n "$script" ] && [ -f "$SOFTWARE_DIR/install/$script" ]; then
        bash "$SOFTWARE_DIR/install/$script" uninstall
    fi
}

service_menu() {
    echo ""
    echo -e "${CYAN}======== 服务管理 ========${NC}"
    echo " 1) Nginx (重载/重启/状态)"
    echo " 2) PHP-FPM (重启/状态)"
    echo " 3) MySQL (重启/状态)"
    echo " 4) Redis (重启/状态)"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) nginx_ctl;;
        2) php_ctl;;
        3) mysql_ctl;;
        4) redis_ctl;;
    esac
}
# ================== 备份管理 ==================
# ================== 备份配置 ==================
BACKUP_CONF="/opt/site_manager/config/backup.conf"
[ -f "$BACKUP_CONF" ] && source "$BACKUP_CONF"
BACKUP_DIR="${BACKUP_DIR:-/www/backup}"
BACKUP_KEEP="${BACKUP_KEEP:-7}"

# ================== 备份管理 ==================
backup_menu() {
    echo ""
    echo -e "${CYAN}======== 备份管理 ========${NC}"
    echo " 1) 备份站点"
    echo " 2) 恢复站点"
    echo " 3) 备份数据库"
    echo " 4) 恢复数据库"
    echo " 5) 查看备份"
    echo " 6) 备份设置"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) backup_site;;
        2) restore_site;;
        3) backup_db;;
        4) restore_db;;
        5) list_backups;;
        6) backup_settings;;
    esac
}

# 上传到 FTP
upload_to_ftp() {
    local file="$1"
    [ "$FTP_ENABLED" != "true" ] && return 0
    [ -z "$FTP_HOST" ] && return 0
    
    log_info "上传到 FTP: $(basename "$file")"
    
    curl -s -T "$file" "ftp://${FTP_HOST}:${FTP_PORT}${FTP_PATH}/$(basename "$file")" \
        --user "${FTP_USER}:${FTP_PASS}" \
        --ftp-create-dirs 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}FTP上传成功${NC}"
        [ "$FTP_DELETE_LOCAL" = "true" ] && rm -f "$file" && echo "本地文件已删除"
        return 0
    else
        echo -e "${RED}FTP上传失败${NC}"
        return 1
    fi
}

# 清理旧备份
cleanup_backups() {
    local pattern="$1"
    local keep="${BACKUP_KEEP:-7}"

    # 安全检查：确保 pattern 不为空
    [ -z "$pattern" ] && return 1

    # 安全检查：确保 BACKUP_DIR 存在且不为空
    [ -z "$BACKUP_DIR" ] && return 1
    [ ! -d "$BACKUP_DIR" ] && return 0

    # 本地清理
    local files=()
    while IFS= read -r -d '' f; do
        files+=("$f")
    done < <(find "$BACKUP_DIR" -maxdepth 1 -name "${pattern}*" -type f -print0 2>/dev/null | sort -z -r)

    local count=${#files[@]}
    if [ "$count" -gt "$keep" ]; then
        local deleted=0
        for ((i=keep; i<count; i++)); do
            rm -f "${files[$i]}" && ((deleted++))
        done
        [ "$deleted" -gt 0 ] && echo -e "${CYAN}已清理 $deleted 个旧备份，保留最新 $keep 份${NC}"
    fi
}

backup_site() {
    echo ""
    echo -e "${CYAN}选择要备份的站点:${NC}"
    
    local i=1
    local sites=()
    for conf in "$NGINX_CONF_DIR"/*; do
        [ -f "$conf" ] || continue
        local name=$(basename "$conf")
        [[ "$name" == "default" || "$name" == *.bak ]] && continue
        local domain="${name%.conf}"
        sites+=("$domain")
        printf " %2d) %s\n" $i "$domain"
        ((i++))
    done
    
    [ ${#sites[@]} -eq 0 ] && echo "无站点" && return
    echo "  a) 备份全部"
    echo "  0) 返回"
    echo ""
    read -p "编号: " n
    
    mkdir -p "$BACKUP_DIR"

    # 检查磁盘空间 (至少保留 500MB)
    local avail=$(df -m "$BACKUP_DIR" 2>/dev/null | awk 'NR==2 {print $4}')
    if [ -n "$avail" ] && [ "$avail" -lt 500 ]; then
        echo -e "${RED}磁盘空间不足 (剩余 ${avail}MB)，请先清理${NC}"
        return 1
    fi

    if [ "$n" = "a" ]; then
        local success=0 fail=0
        for d in "${sites[@]}"; do
            local file="$BACKUP_DIR/${d}_$(date +%Y%m%d_%H%M%S).tar.gz"
            if [ ! -d "$SITES_DIR/$d" ]; then
                echo -e "${YELLOW}跳过: $d (目录不存在)${NC}"
                ((fail++))
                continue
            fi
            if tar -czf "$file" -C "$SITES_DIR" "$d" 2>/dev/null; then
                echo -e "${GREEN}备份成功: $d ($(du -h "$file" | cut -f1))${NC}"
                upload_to_ftp "$file"
                cleanup_backups "${d}_"
                ((success++))
            else
                echo -e "${RED}备份失败: $d${NC}"
                rm -f "$file"
                ((fail++))
            fi
        done
        echo -e "\n备份完成: ${GREEN}成功 $success${NC}, ${RED}失败 $fail${NC}"
        return
    fi

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#sites[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local d="${sites[$((n-1))]}"
    local file="$BACKUP_DIR/${d}_$(date +%Y%m%d_%H%M%S).tar.gz"

    if [ ! -d "$SITES_DIR/$d" ]; then
        echo -e "${RED}站点目录不存在: $SITES_DIR/$d${NC}"
        return 1
    fi

    if tar -czf "$file" -C "$SITES_DIR" "$d" 2>/dev/null; then
        echo -e "${GREEN}备份成功: $file ($(du -h "$file" | cut -f1))${NC}"
        upload_to_ftp "$file"
        cleanup_backups "${d}_"
    else
        echo -e "${RED}备份失败${NC}"
        rm -f "$file"
        return 1
    fi
}

restore_site() {
    echo ""
    echo -e "${CYAN}选择要恢复的备份:${NC}"
    
    local i=1
    local files=()
    for f in $BACKUP_DIR/*.tar.gz; do
        [ -f "$f" ] || continue
        files+=("$f")
        printf " %2d) %s\n" $i "$(basename "$f")"
        ((i++))
    done
    
    [ ${#files[@]} -eq 0 ] && echo "无备份" && return
    echo "  0) 返回"
    echo ""
    read -p "编号: " n
    
    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#files[@]} ] && echo -e "${RED}无效编号${NC}" && return
    
    local f="${files[$((n-1))]}"
    tar -xzf "$f" -C "$SITES_DIR" && echo -e "${GREEN}恢复成功${NC}"
}

backup_db() {
    echo ""
    echo -e "${CYAN}选择要备份的数据库:${NC}"
    
    local i=1
    local dbs=()
    while read -r db; do
        [[ "$db" =~ ^(Database|information_schema|performance_schema|mysql|sys)$ ]] && continue
        dbs+=("$db")
        printf " %2d) %s\n" $i "$db"
        ((i++))
    done < <(mysql_exec -N -e "SHOW DATABASES;")

    [ ${#dbs[@]} -eq 0 ] && echo -e "${RED}无数据库或无法连接 MySQL${NC}" && return
    echo "  a) 备份全部"
    echo "  0) 返回"
    echo ""
    read -p "编号: " n

    mkdir -p "$BACKUP_DIR"

    if [ "$n" = "a" ]; then
        local success=0 fail=0
        for db in "${dbs[@]}"; do
            local file="$BACKUP_DIR/${db}_$(date +%Y%m%d_%H%M%S).sql"
            if mysqldump_exec "$db" "$file"; then
                echo -e "${GREEN}备份成功: $db${NC}"
                upload_to_ftp "$file"
                cleanup_backups "${db}_"
                ((success++))
            else
                ((fail++))
            fi
        done
        echo -e "\n备份完成: ${GREEN}成功 $success${NC}, ${RED}失败 $fail${NC}"
        return
    fi

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#dbs[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local db="${dbs[$((n-1))]}"
    local file="$BACKUP_DIR/${db}_$(date +%Y%m%d_%H%M%S).sql"
    if mysqldump_exec "$db" "$file"; then
        echo -e "${GREEN}备份成功: $file${NC}"
        upload_to_ftp "$file"
        cleanup_backups "${db}_"
    fi
}

restore_db() {
    echo ""
    echo -e "${CYAN}选择要恢复的备份:${NC}"

    local i=1
    local files=()
    for f in $BACKUP_DIR/*.sql; do
        [ -f "$f" ] || continue
        files+=("$f")
        printf " %2d) %s ($(du -h "$f" | cut -f1))\n" $i "$(basename "$f")"
        ((i++))
    done

    [ ${#files[@]} -eq 0 ] && echo "无SQL备份" && return
    echo "  0) 返回"
    echo ""
    read -p "编号: " n

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#files[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local f="${files[$((n-1))]}"
    local dbname=$(basename "$f" .sql | sed 's/_[0-9]*$//' | sed 's/_[0-9]*$//')
    read -p "数据库名 [$dbname]: " input_db
    dbname="${input_db:-$dbname}"

    echo "正在恢复..."
    if mysql_exec "$dbname" < "$f"; then
        echo -e "${GREEN}恢复成功: $dbname${NC}"
    else
        echo -e "${RED}恢复失败，请检查数据库是否存在或凭据是否正确${NC}"
        return 1
    fi
}

list_backups() {
    echo ""
    echo -e "${CYAN}======== 本地备份 ========${NC}"
    if [ -d "$BACKUP_DIR" ] && [ "$(ls -A $BACKUP_DIR 2>/dev/null)" ]; then
        ls -lh "$BACKUP_DIR" | grep -v ^total
        echo ""
        echo -e "保留策略: 最新 ${YELLOW}$BACKUP_KEEP${NC} 份"
    else
        echo "无备份"
    fi
    
    if [ "$FTP_ENABLED" = "true" ]; then
        echo ""
        echo -e "${CYAN}======== FTP远程备份 ========${NC}"
        echo -e "服务器: ${FTP_HOST}:${FTP_PORT}"
        echo -e "路径: ${FTP_PATH}"
    fi
}

backup_settings() {
    echo ""
    echo -e "${CYAN}======== 备份设置 ========${NC}"
    echo -e " 本地目录: $BACKUP_DIR"
    echo -e " 保留份数: $BACKUP_KEEP"
    echo -e " FTP备份:  $([ "$FTP_ENABLED" = "true" ] && echo -e "${GREEN}已开启${NC}" || echo -e "${RED}未开启${NC}")"
    [ "$FTP_ENABLED" = "true" ] && echo -e " FTP服务器: $FTP_HOST:$FTP_PORT"
    echo ""
    echo " 1) 设置保留份数"
    echo " 2) 配置FTP"
    echo " 3) 测试FTP连接"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) set_backup_keep;;
        2) set_ftp_config;;
        3) test_ftp;;
    esac
}

set_backup_keep() {
    read -p "保留最近多少份备份 [$BACKUP_KEEP]: " n
    [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt 0 ] || return
    sed -i "s/^BACKUP_KEEP=.*/BACKUP_KEEP=$n/" "$BACKUP_CONF"
    BACKUP_KEEP=$n
    echo -e "${GREEN}已设置保留 $n 份${NC}"
}

set_ftp_config() {
    echo ""
    echo -e "${CYAN}配置FTP远程备份${NC}"
    read -p "FTP服务器地址: " host
    read -p "FTP端口 [21]: " port
    port="${port:-21}"
    read -p "FTP用户名: " user
    read -s -p "FTP密码: " pass
    echo ""
    read -p "远程目录 [/backup]: " path
    path="${path:-/backup}"
    read -p "上传后删除本地文件? (y/n) [n]: " del
    del="$([ "$del" = "y" ] && echo "true" || echo "false")"
    
    # 保存配置
    cat > "$BACKUP_CONF" << CONF
# 备份配置
BACKUP_DIR="$BACKUP_DIR"
BACKUP_KEEP=$BACKUP_KEEP

# FTP配置
FTP_ENABLED=true
FTP_HOST="$host"
FTP_PORT=$port
FTP_USER="$user"
FTP_PASS="$pass"
FTP_PATH="$path"
FTP_DELETE_LOCAL=$del
CONF
    chmod 600 "$BACKUP_CONF"
    source "$BACKUP_CONF"
    echo -e "${GREEN}FTP配置已保存${NC}"
}

test_ftp() {
    [ "$FTP_ENABLED" != "true" ] && echo -e "${YELLOW}FTP未配置${NC}" && return
    
    echo "测试连接 $FTP_HOST..."
    echo "test" > /tmp/ftp_test.txt
    curl -s -T /tmp/ftp_test.txt "ftp://${FTP_HOST}:${FTP_PORT}${FTP_PATH}/ftp_test.txt" \
        --user "${FTP_USER}:${FTP_PASS}" --ftp-create-dirs 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}FTP连接成功!${NC}"
        # 删除测试文件
        curl -s "ftp://${FTP_HOST}:${FTP_PORT}" --user "${FTP_USER}:${FTP_PASS}" \
            -Q "DELE ${FTP_PATH}/ftp_test.txt" 2>/dev/null
    else
        echo -e "${RED}FTP连接失败${NC}"
    fi
    rm -f /tmp/ftp_test.txt
}

# ================== 安全管理 ==================
security_menu() {
    echo ""
    echo -e "${CYAN}======== 安全管理 ========${NC}"
    echo " 1) 防火墙状态"
    echo " 2) 开启防火墙"
    echo " 3) 关闭防火墙"
    echo " 4) 放行端口"
    echo " 5) 封禁端口"
    echo " 6) 删除规则"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) ufw status numbered;;
        2) ufw --force enable && echo -e "${GREEN}已开启${NC}";;
        3) ufw disable && echo -e "${GREEN}已关闭${NC}";;
        4) read -p "端口: " p; ufw allow "$p/tcp" && echo -e "${GREEN}已放行${NC}";;
        5) read -p "端口: " p; ufw deny "$p/tcp" && echo -e "${GREEN}已封禁${NC}";;
        6) ufw status numbered; read -p "规则编号: " n; echo y | ufw delete "$n";;
    esac
}

# ================== 系统信息 ==================
system_menu() {
    echo ""
    echo -e "${CYAN}======== 系统信息 ========${NC}"
    echo " 1) 系统概览"
    echo " 2) 磁盘使用"
    echo " 3) 内存使用"
    echo " 4) 网络连接"
    echo " 5) 进程列表"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) sys_overview;;
        2) df -h | grep -E "^/dev|^Filesystem";;
        3) free -h;;
        4) ss -tlnp | head -20;;
        5) ps aux --sort=-%cpu | head -15;;
    esac
}

sys_overview() {
    echo ""
    echo -e " 主机: $(hostname)"
    echo -e " 系统: $(grep PRETTY_NAME /etc/os-release | cut -d'"' -f2)"
    echo -e " 内核: $(uname -r)"
    echo -e " CPU:  $(nproc) 核"
    echo -e " 内存: $(free -h | awk '/Mem:/{printf "%s/%s", $3, $2}')"
    echo -e " 磁盘: $(df -h / | awk 'NR==2{printf "%s/%s (%s)", $3, $2, $5}')"
    echo -e " 负载: $(cat /proc/loadavg | awk '{print $1, $2, $3}')"
    echo -e " 运行: $(uptime -p)"
}

# ================== Web面板 ==================
panel_menu() {
    local status="${RED}已停止${NC}"
    pgrep -f "site_manager_panel" > /dev/null && status="${GREEN}运行中${NC}"
    echo ""
    echo -e "${CYAN}======== Web面板 ========${NC}"
    echo -e " 状态: $status"
    echo ""
    echo " 1) 启动"
    echo " 2) 停止"
    echo " 3) 重启"
    echo " 4) 修改端口"
    echo " 5) 重置密码"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) panel_start;;
        2) panel_stop;;
        3) panel_stop; sleep 1; panel_start;;
        4) panel_port;;
        5) panel_password;;
    esac
}

panel_start() {
    pgrep -f "site_manager_panel" > /dev/null && echo -e "${YELLOW}已在运行${NC}" && return
    local port=$([ -f "$PANEL_CONFIG" ] && grep -o '"port":[[:space:]]*[0-9]*' "$PANEL_CONFIG" | grep -o '[0-9]*' || echo "8888")
    cd "$PANEL_DIR" && nohup "$PANEL_BIN" -port "$port" > /tmp/panel.log 2>&1 &
    sleep 2
    local ip=$(curl -s --connect-timeout 2 ifconfig.me 2>/dev/null || hostname -I | awk '{print $1}')
    echo -e "${GREEN}已启动: http://$ip:$port${NC}"
}

panel_stop() {
    pkill -f "site_manager_panel" && echo -e "${GREEN}已停止${NC}" || echo -e "${YELLOW}未运行${NC}"
}

panel_port() {
    local port=$([ -f "$PANEL_CONFIG" ] && grep -o '"port":[[:space:]]*[0-9]*' "$PANEL_CONFIG" | grep -o '[0-9]*' || echo "8888")
    echo "当前端口: $port"
    read -p "新端口: " p
    [[ "$p" =~ ^[0-9]+$ ]] && [ "$p" -ge 1024 ] || { echo -e "${RED}无效${NC}"; return; }
    [ -f "$PANEL_CONFIG" ] && sed -i "s/\"port\":[[:space:]]*[0-9]*/\"port\": $p/" "$PANEL_CONFIG"
    ufw allow "$p/tcp" 2>/dev/null
    echo -e "${GREEN}已改为 $p，请重启面板${NC}"
}

panel_password() {
    [ ! -f "$PANEL_DB" ] && echo -e "${RED}数据库不存在${NC}" && return
    local pass=$(tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 16)
    if command -v python3 &>/dev/null; then
        local hash=$(python3 -c "import bcrypt; print(bcrypt.hashpw('$pass'.encode(), bcrypt.gensalt()).decode())" 2>/dev/null)
        [ -n "$hash" ] && sqlite3 "$PANEL_DB" "UPDATE users SET password='$hash' WHERE username='admin';"
        echo -e "${GREEN}新密码: $pass${NC}"
    else
        echo -e "${YELLOW}需要 python3-bcrypt${NC}"
    fi
}

# ================== 命令行接口 ==================
show_help() {
    echo ""
    echo -e "${GREEN}Site Manager v$VERSION${NC}"
    echo ""
    echo "用法: site [命令] [参数]"
    echo ""
    echo "交互模式:"
    echo "  site -m                 进入交互式菜单"
    echo ""
    echo "站点管理:"
    echo "  site list               查看所有站点"
    echo "  site create <域名> <类型>  创建站点 (php73/php80/php83/static/proxy)"
    echo "  site delete <域名> [--config|--full|--backup]  删除站点"
    echo "  site enable <域名>      启用站点"
    echo "  site disable <域名>     禁用站点"
    echo "  site info <域名>        站点详情"
    echo ""
    echo "SSL证书:"
    echo "  site ssl config         配置 Cloudflare DNS API"
    echo "  site ssl <域名>         申请SSL证书 (HTTP验证)"
    echo "  site ssl <域名> --dns   申请SSL证书 (DNS验证)"
    echo "  site ssl <域名> --wildcard  申请泛域名证书"
    echo "  site ssl renew          续期所有证书"
    echo ""
    echo "备份恢复:"
    echo "  site backup <域名>      备份站点"
    echo "  site restore <域名> <文件>  恢复站点"
    echo "  site db backup [数据库]  备份数据库"
    echo "  site db restore <库> <文件>  恢复数据库"
    echo ""
    echo "软件管理:"
    echo "  site soft               查看已安装软件"
    echo "  site install <软件> [版本]  安装软件"
    echo "  site uninstall <软件>   卸载软件"
    echo "    可用软件: nginx, php, mysql, redis, nodejs, docker"
    echo ""
    echo "服务管理:"
    echo "  site nginx reload|restart|status"
    echo "  site php restart"
    echo "  site mysql restart|status"
    echo "  site redis restart|status"
    echo ""
    echo "安全管理:"
    echo "  site firewall status|on|off"
    echo "  site firewall allow <端口>"
    echo "  site firewall deny <端口>"
    echo ""
    echo "Web面板:"
    echo "  site panel start|stop|restart"
    echo ""
}

# ================== 命令行处理 ==================
handle_cli() {
    case "$1" in
        list) site_list;;
        create) [ -n "$2" ] && [ -n "$3" ] && {
            domain="$2"; type_arg="$3"
            local type="" php_version=""
            # 解析类型参数
            if [[ "$type_arg" =~ ^php([0-9])([0-9]+)$ ]]; then
                type="php"
                php_version="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
            elif [[ "$type_arg" == "static" ]]; then
                type="static"
            elif [[ "$type_arg" == "proxy" ]]; then
                type="proxy"
            else
                echo "无效类型: $type_arg (支持: php73/php80/php81/php83/static/proxy)"
                exit 1
            fi
            _do_site_create "$domain" "$type" "$php_version"
        } || echo "用法: site create <域名> <类型> (php73/php80/php81/php83/static/proxy)";;
        delete)
            if [ -z "$2" ]; then
                echo "用法: site delete <域名> [选项]"
                echo "选项:"
                echo "  --config     仅删除配置 (保留文件)"
                echo "  --full       删除配置和站点文件 (需确认)"
                echo "  --full --yes 删除配置和站点文件 (跳过确认)"
                echo "  --backup     备份后删除全部"
                echo "  (无选项)     仅删除配置 (需确认)"
            else
                local mode="config"
                local skip_confirm=""
                case "$3" in
                    --config) mode="config";;
                    --full) mode="full"; [ "$4" = "--yes" ] && skip_confirm="--yes";;
                    --backup) mode="backup";;
                    --yes) mode="config";;  # 仅 --yes 时默认 config 模式
                    "")
                        # 无选项时交互确认后删除配置
                        validate_domain "$2" || exit 1
                        [ ! -f "$NGINX_CONF_DIR/$2" ] && echo -e "${RED}站点不存在${NC}" && exit 1
                        read -p "确认删除 $2 的配置? (y/n): " c
                        [ "$c" != "y" ] && echo "已取消" && exit 0
                        mode="config"
                        ;;
                    *)
                        echo -e "${RED}无效选项: $3${NC}"
                        exit 1
                        ;;
                esac
                _do_site_delete "$2" "$mode" "$skip_confirm" || exit 1
            fi
            ;;
        enable) [ -n "$2" ] && site_enable "$2" || echo "用法: site enable <域名>";;
        disable) [ -n "$2" ] && site_disable "$2" || echo "用法: site disable <域名>";;
        info) [ -n "$2" ] && site_info "$2" || echo "用法: site info <域名>";;
        ssl) source /opt/site_manager/lib/ssl.sh 2>/dev/null || source "$SCRIPT_DIR/../lib/ssl.sh"
            case "$2" in
                config) ssl_dns_config "$3" "$4";;
                install) ssl_install;;
                renew) ssl_renew;;
                "") echo "用法: site ssl <域名> [--dns] [--wildcard]";;
                *) ssl_request "$2" "${@:3}";;
            esac;;
        backup)
            if [ -z "$2" ]; then
                echo "用法: site backup <域名>"
            else
                mkdir -p "$BACKUP_DIR"
                # 检查磁盘空间
                local avail=$(df -m "$BACKUP_DIR" 2>/dev/null | awk 'NR==2 {print $4}')
                if [ -n "$avail" ] && [ "$avail" -lt 500 ]; then
                    echo -e "${RED}磁盘空间不足 (剩余 ${avail}MB)${NC}"
                    exit 1
                fi
                if [ ! -d "$SITES_DIR/$2" ]; then
                    echo -e "${RED}站点目录不存在: $SITES_DIR/$2${NC}"
                    exit 1
                fi
                local file="$BACKUP_DIR/${2}_$(date +%Y%m%d_%H%M%S).tar.gz"
                if tar -czf "$file" -C "$SITES_DIR" "$2" 2>/dev/null; then
                    echo -e "${GREEN}备份成功: $file ($(du -h "$file" | cut -f1))${NC}"
                    cleanup_backups "${2}_"
                else
                    echo -e "${RED}备份失败${NC}"
                    rm -f "$file"
                    exit 1
                fi
            fi
            ;;
        restore)
            if [ -z "$2" ] || [ -z "$3" ]; then
                echo "用法: site restore <域名> <备份文件>"
            elif [ ! -f "$3" ]; then
                echo -e "${RED}备份文件不存在: $3${NC}"
                exit 1
            else
                if tar -xzf "$3" -C "$SITES_DIR" 2>/dev/null; then
                    chown -R www:www "$SITES_DIR/$2" 2>/dev/null
                    echo -e "${GREEN}恢复成功${NC}"
                else
                    echo -e "${RED}恢复失败${NC}"
                    exit 1
                fi
            fi
            ;;
        db) source /opt/site_manager/lib/db.sh; case "$2" in
                create) db_create "$3";;
                drop) db_drop "$3";;
                import) db_import "$3" "$4";;
                export) db_export "$3";;
                list) db_list;;
                backup) mkdir -p "$BACKUP_DIR"; if [ -n "$3" ]; then mysqldump_exec "$3" "$BACKUP_DIR/${3}_$(date +%Y%m%d_%H%M%S).sql" && echo "备份成功"; else echo "用法: site db backup <数据库名>"; fi;;
                restore) if [ -n "$3" ] && [ -n "$4" ] && [ -f "$4" ]; then mysql_exec "$3" < "$4" && echo "恢复成功" || echo -e "${RED}恢复失败${NC}"; else echo "用法: site db restore <库> <文件>"; fi;;
                *) echo "用法: site db <create|drop|import|export|list|backup|restore>";;
            esac;;
        nginx) case "$2" in reload)systemctl reload nginx;; restart)systemctl restart nginx;; status)systemctl status nginx --no-pager;; *)systemctl reload nginx;; esac;;
        php) [ "$2" = "restart" ] && for v in 7.4 8.0 8.1 8.2 8.3; do systemctl restart "php${v}-fpm" 2>/dev/null; done || php -v;;
        mysql) case "$2" in restart)systemctl restart mysql;; status)systemctl status mysql --no-pager;; *)systemctl status mysql --no-pager;; esac;;
        redis) case "$2" in restart)systemctl restart redis-server;; *)systemctl status redis-server --no-pager;; esac;;
        firewall) case "$2" in
                status) ufw status numbered;;
                on) ufw --force enable;;
                off) ufw disable;;
                allow) [ -n "$3" ] && ufw allow "$3/tcp";;
                deny) [ -n "$3" ] && ufw deny "$3/tcp";;
                *) ufw status;;
            esac;;
        soft) soft_list;;
        install) [ -n "$2" ] && { local script="${2}.sh"; [ -f "$SOFTWARE_DIR/install/$script" ] && bash "$SOFTWARE_DIR/install/$script" install "$3" || echo "未知软件: $2"; } || echo "用法: site install <软件> [版本]";;
        uninstall) [ -n "$2" ] && { local script="${2}.sh"; [ -f "$SOFTWARE_DIR/install/$script" ] && bash "$SOFTWARE_DIR/install/$script" uninstall || echo "未知软件: $2"; } || echo "用法: site uninstall <软件>";;
        panel) case "$2" in start)panel_start;; stop)panel_stop;; restart)panel_stop;sleep 1;panel_start;; *)panel_menu;; esac;;
        help|--help|-h) show_help;;
        *) show_help;;
    esac
}

# ================== 交互式菜单 ==================
interactive_menu() {
    while true; do
        show_menu
        read -p "选项: " c
        case "$c" in
            1) site_menu;;
            2) software_menu;;
            3) backup_menu;;
            4) security_menu;;
            5) system_menu;;
            6) panel_menu;;
            0|q) exit 0;;
            *) echo -e "${RED}无效选项${NC}";;
        esac
        echo ""
        read -p "按回车继续..."
    done
}

# ================== 主入口 ==================
main() {
    [ "$EUID" -ne 0 ] && echo "请用 root 权限运行" && exit 1

    if [ $# -eq 0 ]; then
        show_help
    else
        case "$1" in
            -m|menu) interactive_menu;;
            *) handle_cli "$@";;
        esac
    fi
}

main "$@"
