#!/bin/bash
#
# Site Manager - 统一管理工具
# 用法: site [命令]
#

VERSION="2.0.0"
ROOT_DIR="/opt/site_manager"
PANEL_DIR="$ROOT_DIR/panel"
PANEL_BIN="$PANEL_DIR/site_manager_panel"
PANEL_CONFIG="$PANEL_DIR/config/config.json"
PANEL_DB="$PANEL_DIR/data/panel.db"

# 颜色
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
CYAN="\033[36m"
NC="\033[0m"

# 加载库文件
[ -f "$ROOT_DIR/lib/colors.sh" ] && source "$ROOT_DIR/lib/colors.sh"
[ -f "$ROOT_DIR/lib/utils.sh" ] && source "$ROOT_DIR/lib/utils.sh"
[ -f "$ROOT_DIR/config/site_manager.conf" ] && source "$ROOT_DIR/config/site_manager.conf"

NGINX_CONF_DIR="${NGINX_CONF_DIR:-/etc/nginx/sites-available}"
NGINX_ENABLED_DIR="${NGINX_ENABLED_DIR:-/etc/nginx/sites-enabled}"
SITES_DIR="${SITES_DIR:-/www/wwwroot}"
LOGS_DIR="${LOGS_DIR:-/www/wwwlogs}"

# 检查/创建 www 用户和组
ensure_www_user() {
    if ! getent group www >/dev/null 2>&1; then
        groupadd www || { echo -e "${RED}创建 www 组失败${NC}"; return 1; }
    fi
    if ! getent passwd www >/dev/null 2>&1; then
        useradd -g www -s /sbin/nologin -M www || { echo -e "${RED}创建 www 用户失败${NC}"; return 1; }
    fi
    return 0
}

# 验证域名格式
validate_domain() {
    local domain="$1"
    if [[ ! "$domain" =~ ^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$ ]]; then
        echo -e "${RED}无效的域名格式: $domain${NC}"
        return 1
    fi
    return 0
}

# 获取 MySQL 连接参数
get_mysql_args() {
    local args=""
    if [ -n "$MYSQL_USER" ] && [ -n "$MYSQL_PASS" ]; then
        args="-u$MYSQL_USER -p$MYSQL_PASS"
    elif [ -f "${MYSQL_DEFAULTS_FILE:-/www/server/panel/data/default.pl}" ]; then
        local pass=$(cat "${MYSQL_DEFAULTS_FILE:-/www/server/panel/data/default.pl}" 2>/dev/null)
        [ -n "$pass" ] && args="-uroot -p$pass"
    fi
    echo "$args"
}

# 执行 MySQL 命令 (带错误处理)
mysql_exec() {
    local args=$(get_mysql_args)
    mysql $args "$@" 2>/dev/null
}

# 执行 mysqldump (带错误处理)
mysqldump_exec() {
    local args=$(get_mysql_args)
    local db="$1"
    local output="$2"

    if ! mysqldump $args --single-transaction --quick "$db" > "$output" 2>/dev/null; then
        echo -e "${RED}备份失败: $db${NC}"
        rm -f "$output"
        return 1
    fi

    # 检查输出文件是否有效
    if [ ! -s "$output" ]; then
        echo -e "${RED}备份文件为空: $db${NC}"
        rm -f "$output"
        return 1
    fi

    return 0
}

# 安全的 nginx 配置测试和重载
nginx_safe_reload() {
    local rollback_files=("$@")

    if nginx -t 2>/dev/null; then
        systemctl reload nginx
        return 0
    else
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5

        # 回滚：删除刚创建的配置文件
        for f in "${rollback_files[@]}"; do
            [ -f "$f" ] && rm -f "$f"
            [ -L "$f" ] && rm -f "$f"
        done

        echo -e "${YELLOW}已回滚配置更改${NC}"
        return 1
    fi
}

# ================== 伪静态管理 ==================
NGINX_REWRITE_DIR="${NGINX_REWRITE_DIR:-/www/vhost/rewrite}"
REWRITE_TEMPLATES_DIR="${REWRITE_TEMPLATES_DIR:-/opt/site_manager/config/rewrite}"

# 列出可用的伪静态规则
list_rewrite_rules() {
    echo ""
    echo -e "${CYAN}可用的伪静态规则:${NC}"
    for f in "$REWRITE_TEMPLATES_DIR"/*.conf; do
        [ -f "$f" ] || continue
        local name=$(basename "$f" .conf)
        local desc=$(head -1 "$f" | sed 's/^# //')
        printf "  %-12s %s\n" "$name" "$desc"
    done
    echo ""
}

# 获取站点当前伪静态规则
get_site_rewrite() {
    local domain="$1"
    local rewrite_file="$NGINX_REWRITE_DIR/$domain.conf"

    if [ -f "$rewrite_file" ]; then
        # 读取规则类型注释
        local rule=$(head -1 "$rewrite_file" | sed 's/^# //' | sed 's/ 伪静态规则//')
        echo "$rule"
    else
        echo "无"
    fi
}

# 设置站点伪静态规则
set_site_rewrite() {
    local domain="$1"
    local rule="$2"

    validate_domain "$domain" || return 1

    local conf_path="$NGINX_CONF_DIR/$domain"
    [ ! -f "$conf_path" ] && echo -e "${RED}站点不存在: $domain${NC}" && return 1

    mkdir -p "$NGINX_REWRITE_DIR"

    local template="$REWRITE_TEMPLATES_DIR/${rule}.conf"
    local rewrite_file="$NGINX_REWRITE_DIR/$domain.conf"

    if [ ! -f "$template" ]; then
        echo -e "${RED}伪静态规则不存在: $rule${NC}"
        list_rewrite_rules
        return 1
    fi

    # 备份原配置
    cp "$conf_path" "$conf_path.bak"

    # 移除已有的 location / 块 (硬编码的伪静态规则)
    # 使用 sed 删除 location / { ... } 块
    sed -i '/location \/ {/,/^    }/d' "$conf_path"

    # 移除旧的 rewrite include 和注释
    sed -i '/# 伪静态规则/d' "$conf_path"
    sed -i "/include.*rewrite.*$domain/d" "$conf_path"

    # 复制新规则
    cp "$template" "$rewrite_file"

    # 在最后一个 } 前添加 include
    sed -i "/^}$/i\\    # 伪静态规则\\n    include $NGINX_REWRITE_DIR/$domain.conf;" "$conf_path"

    # 测试配置
    if nginx -t 2>/dev/null; then
        systemctl reload nginx
        rm -f "$conf_path.bak"
        echo -e "${GREEN}伪静态规则已设置: $domain -> $rule${NC}"
    else
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5
        mv "$conf_path.bak" "$conf_path"
        rm -f "$rewrite_file"
        return 1
    fi
}

# 交互式设置伪静态
rewrite_menu() {
    local domain="$1"

    if [ -z "$domain" ]; then
        site_list
        read -p "域名: " domain
        [ -z "$domain" ] && return
    fi

    validate_domain "$domain" || return 1
    [ ! -f "$NGINX_CONF_DIR/$domain" ] && echo -e "${RED}站点不存在${NC}" && return

    local current=$(get_site_rewrite "$domain")
    echo ""
    echo -e "站点: ${CYAN}$domain${NC}"
    echo -e "当前规则: ${YELLOW}$current${NC}"
    echo ""

    local i=1
    local rules=()
    for f in "$REWRITE_TEMPLATES_DIR"/*.conf; do
        [ -f "$f" ] || continue
        local name=$(basename "$f" .conf)
        rules+=("$name")
        local desc=$(head -1 "$f" | sed 's/^# //')
        printf " %2d) %-12s %s\n" $i "$name" "$desc"
        ((i++))
    done
    echo "  0) 返回"
    echo ""
    read -p "选择规则: " choice

    if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -gt 0 ] && [ "$choice" -le ${#rules[@]} ]; then
        set_site_rewrite "$domain" "${rules[$((choice-1))]}"
    elif [ "$choice" != "0" ]; then
        echo -e "${RED}无效选择${NC}"
    fi
}

# 自动检测已安装的 PHP-FPM 版本
detect_php_fpm() {
    local php_sock=""
    for v in 8.3 8.2 8.1 8.0 7.4; do
        if [[ -S "/run/php/php${v}-fpm.sock" ]]; then
            php_sock="/run/php/php${v}-fpm.sock"
            break
        fi
    done
    # 如果没找到，默认使用 8.3
    echo "${php_sock:-/run/php/php8.3-fpm.sock}"
}
PHP_FPM_SOCK=$(detect_php_fpm)

# 检查指定 PHP 版本是否已安装
check_php_installed() {
    local version="$1"  # 如 7.3, 8.0, 8.3
    [[ -S "/run/php/php${version}-fpm.sock" ]] && return 0
    command -v "php${version}" &>/dev/null && return 0
    return 1
}

# 安装指定 PHP 版本
install_php_version() {
    local version="$1"
    echo -e "${CYAN}正在安装 PHP ${version}...${NC}"
    
    # 添加 PHP 源 (如果不存在)
    if [[ ! -f /etc/apt/sources.list.d/php.list ]]; then
        curl -sSL https://packages.sury.org/php/apt.gpg | gpg --dearmor -o /usr/share/keyrings/php-archive-keyring.gpg 2>/dev/null
        echo "deb [signed-by=/usr/share/keyrings/php-archive-keyring.gpg] https://packages.sury.org/php/ $(lsb_release -sc) main" > /etc/apt/sources.list.d/php.list
        apt-get update -qq
    fi
    
    local extensions="fpm cli common mysql curl gd mbstring xml zip bcmath redis intl"
    local pkgs=""
    for ext in $extensions; do
        pkgs="$pkgs php${version}-${ext}"
    done
    
    apt-get install -y -qq $pkgs > /dev/null 2>&1 || { echo -e "${RED}PHP ${version} 安装失败${NC}"; return 1; }
    
    # 配置 PHP-FPM
    local fpm_conf="/etc/php/${version}/fpm/pool.d/www.conf"
    if [[ -f "$fpm_conf" ]]; then
        sed -i "s/^user = .*/user = www/" "$fpm_conf"
        sed -i "s/^group = .*/group = www/" "$fpm_conf"
        sed -i "s/^listen.owner = .*/listen.owner = www/" "$fpm_conf"
        sed -i "s/^listen.group = .*/listen.group = www/" "$fpm_conf"
    fi
    
    systemctl enable "php${version}-fpm" 2>/dev/null
    systemctl restart "php${version}-fpm"
    echo -e "${GREEN}PHP ${version} 安装完成${NC}"
    return 0
}

# 解析 PHP 类型参数 (php73 -> 7.3)
parse_php_version() {
    local type="$1"
    if [[ "$type" =~ ^php([0-9])([0-9]+)$ ]]; then
        echo "${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
    fi
}

# ================== 主菜单 ==================
show_menu() {
    clear
    echo ""
    echo -e "${GREEN}================ Site Manager v$VERSION ================${NC}"
    echo ""
    echo -e " 1) 站点管理              4) 安全管理"
    echo -e " 2) 软件管理              5) 系统信息"
    echo -e " 3) 备份管理              6) Web面板"
    echo ""
    echo -e " 0) 退出"
    echo -e "${GREEN}=======================================================${NC}"
    echo ""
}

# ================== 站点管理 ==================
site_menu() {
    echo ""
    echo -e "${CYAN}======== 站点管理 ========${NC}"
    echo " 1) 查看所有站点"
    echo " 2) 创建站点"
    echo " 3) 删除站点"
    echo " 4) 启用站点"
    echo " 5) 禁用站点"
    echo " 6) 申请SSL证书"
    echo " 7) 续期SSL证书"
    echo " 8) 站点详情"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) site_list;;
        2) site_create;;
        3) site_delete;;
        4) read -p "域名: " d; [ -n "$d" ] && site_enable "$d";;
        5) read -p "域名: " d; [ -n "$d" ] && site_disable "$d";;
        6) site_list; read -p "域名: " d; [ -n "$d" ] && ssl_request "$d";;
        7) ssl_renew;;
        8) read -p "域名: " d; [ -n "$d" ] && site_info "$d";;
    esac
}

site_list() {
    echo ""
    printf "%-30s %-12s %-10s\n" "域名" "类型" "状态"
    printf "%-30s %-12s %-10s\n" "----" "----" "----"
    for conf in "$NGINX_CONF_DIR"/*; do
        [ -f "$conf" ] || continue
        local name=$(basename "$conf")
        [[ "$name" == "default" || "$name" == *.bak ]] && continue
        local domain="${name%.conf}"
        local type="static"
        local php_ver=""
        # 检测类型和 PHP 版本
        if grep -q "fastcgi_pass" "$conf"; then
            php_ver=$(grep -oP "php\K[0-9]+\.[0-9]+" "$conf" | head -1)
            type="php${php_ver:+ $php_ver}"
        elif grep -q "proxy_pass" "$conf"; then
            type="proxy"
        fi
        local status="disabled"
        [ -L "$NGINX_ENABLED_DIR/$domain" ] || [ -L "$NGINX_ENABLED_DIR/$name" ] && status="${GREEN}enabled${NC}"
        printf "%-30s %-12s %-10b\n" "$domain" "$type" "$status"
    done
    echo ""
}

site_create() {
    read -p "域名: " domain
    [ -z "$domain" ] && echo -e "${RED}域名不能为空${NC}" && return
    
    echo -e " ${CYAN}选择站点类型:${NC}"
    echo " 1) PHP 8.3    4) PHP 7.4"
    echo " 2) PHP 8.1    5) 静态站点"
    echo " 3) PHP 8.0    6) 反向代理"
    read -p "类型 [1]: " t
    
    local type="" php_version=""
    case "$t" in
        1|"") type="php"; php_version="8.3";;
        2) type="php"; php_version="8.1";;
        3) type="php"; php_version="8.0";;
        4) type="php"; php_version="7.4";;
        5) type="static";;
        6) type="proxy";;
        *) type="php"; php_version="8.3";;
    esac

    _do_site_create "$domain" "$type" "$php_version"
}

# 设置应用站点 (node/pm2/python/docker)
_setup_app_site() {
    local domain="$1"
    local type="$2"
    local port="$3"
    local site_path="$SITES_DIR/$domain"

    case "$type" in
        node)
            # Supervisor 配置
            local sv_conf_dir="${SUPERVISOR_CONF_DIR:-/etc/supervisor/conf.d}"; mkdir -p "$sv_conf_dir"
            cat > "$sv_conf_dir/$domain.conf" << EOF
[program:$domain]
command=node $site_path/server.js
directory=$site_path
user=www
autostart=true
autorestart=true
environment=NODE_ENV="production",PORT="$port"
stdout_logfile=$LOGS_DIR/${domain}_node.log
stderr_logfile=$LOGS_DIR/${domain}_node_error.log
EOF
            # 示例 server.js
            cat > "$site_path/server.js" << 'NODEJS'
const http = require('http');
const port = process.env.PORT || 3000;
http.createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});
    res.end('<h1>Node.js 站点运行中</h1>');
}).listen(port, () => console.log(`Server on port ${port}`));
NODEJS
            command -v supervisorctl &>/dev/null && supervisorctl reread && supervisorctl update
            echo -e "${CYAN}Node.js 站点使用端口: $port${NC}"
            echo -e "${CYAN}Supervisor 配置: $sv_conf_dir/$domain.conf${NC}"
            ;;
        pm2)
            # PM2 ecosystem 配置
            cat > "$site_path/ecosystem.config.js" << EOF
module.exports = {
  apps: [{
    name: '$domain',
    script: 'server.js',
    cwd: '$site_path',
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '500M',
    env: { NODE_ENV: 'production', PORT: $port }
  }]
};
EOF
            # 示例 server.js
            cat > "$site_path/server.js" << 'NODEJS'
const http = require('http');
const port = process.env.PORT || 3000;
http.createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});
    res.end('<h1>PM2 站点运行中</h1>');
}).listen(port, () => console.log(`Server on port ${port}`));
NODEJS
            # 启动 PM2
            if command -v pm2 &>/dev/null; then
                run_pm2 start "$site_path/ecosystem.config.js" 2>/dev/null || true
                run_pm2 save 2>/dev/null || true
            else
                echo -e "${YELLOW}PM2 未安装，请先安装: site install nodejs${NC}"
            fi
            echo -e "${CYAN}PM2 站点使用端口: $port${NC}"
            echo -e "${CYAN}PM2 配置: $site_path/ecosystem.config.js${NC}"
            ;;
        python)
            # Supervisor 配置
            local sv_conf_dir="${SUPERVISOR_CONF_DIR:-/etc/supervisor/conf.d}"; mkdir -p "$sv_conf_dir"
            cat > "$sv_conf_dir/$domain.conf" << EOF
[program:$domain]
command=python3 $site_path/app.py
directory=$site_path
user=www
autostart=true
autorestart=true
environment=PORT="$port"
stdout_logfile=$LOGS_DIR/${domain}_python.log
stderr_logfile=$LOGS_DIR/${domain}_python_error.log
EOF
            # 示例 app.py
            cat > "$site_path/app.py" << 'PYTHON'
import os
from http.server import HTTPServer, SimpleHTTPRequestHandler
port = int(os.environ.get('PORT', 8000))
print(f'Server on port {port}')
HTTPServer(('', port), SimpleHTTPRequestHandler).serve_forever()
PYTHON
            command -v supervisorctl &>/dev/null && supervisorctl reread && supervisorctl update
            echo -e "${CYAN}Python 站点使用端口: $port${NC}"
            echo -e "${CYAN}Supervisor 配置: $sv_conf_dir/$domain.conf${NC}"
            ;;
        docker)
            # Docker compose 配置
            cat > "$site_path/docker-compose.yml" << EOF
services:
  app:
    build: .
    ports:
      - "$port:$port"
    environment:
      - PORT=$port
    restart: unless-stopped
EOF
            cat > "$site_path/Dockerfile" << 'DOCKER'
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install --production
COPY . .
CMD ["node", "server.js"]
DOCKER
            cat > "$site_path/server.js" << 'NODEJS'
const http = require('http');
const port = process.env.PORT || 3000;
http.createServer((req, res) => {
    res.writeHead(200, {'Content-Type': 'text/html; charset=utf-8'});
    res.end('<h1>Docker 站点运行中</h1>');
}).listen(port, () => console.log(`Server on port ${port}`));
NODEJS
            echo '{"name":"app","version":"1.0.0","main":"server.js"}' > "$site_path/package.json"
            echo -e "${CYAN}Docker 站点使用端口: $port${NC}"
            echo -e "${CYAN}启动命令: cd $site_path && docker compose up -d${NC}"
            ;;
    esac

    chown -R www:www "$site_path"
}

# 实际创建站点的函数
_do_site_create() {
    local domain="$1"
    local type="$2"
    local php_version="$3"

    # 验证域名格式
    validate_domain "$domain" || return 1

    # 确保 www 用户存在
    ensure_www_user || return 1

    local site_path="$SITES_DIR/$domain"
    local conf_path="$NGINX_CONF_DIR/$domain"

    [ -f "$conf_path" ] && echo -e "${RED}站点已存在${NC}" && return 1

    # PHP 站点检查并安装
    if [[ "$type" == "php" && -n "$php_version" ]]; then
        if ! check_php_installed "$php_version"; then
            echo -e "${YELLOW}PHP $php_version 未安装，正在自动安装...${NC}"
            install_php_version "$php_version" || return 1
        fi
    fi

    # 创建目录（已有项目则跳过默认文件）
    local is_empty=true
    [ -d "$site_path" ] && [ -n "$(ls -A "$site_path" 2>/dev/null)" ] && is_empty=false

    if [ "$type" = "php" ]; then
        mkdir -p "$site_path/public"
        local root="$site_path/public"
        [ "$is_empty" = true ] && echo "<?php phpinfo();" > "$root/index.php"
    else
        mkdir -p "$site_path"
        local root="$site_path"
        [ "$is_empty" = true ] && echo "<h1>Welcome to $domain</h1>" > "$root/index.html"
    fi
    chown -R www:www "$site_path" && chmod -R 755 "$site_path" && find "$site_path" -type f -exec chmod 644 {} \;

    # 生成配置
    cat > "$conf_path" << NGINX
server {
    listen 80;
    server_name $domain;
    root $root;
    index index.php index.html;

    access_log $LOGS_DIR/${domain}_access.log;
    error_log $LOGS_DIR/${domain}_error.log;
NGINX

    if [ "$type" = "php" ]; then
        local php_sock="/run/php/php${php_version}-fpm.sock"
        cat >> "$conf_path" << NGINX

    location / {
        try_files \$uri \$uri/ /index.php?\$query_string;
    }

    location ~ \\.php\$ {
        fastcgi_pass unix:${php_sock};
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
        include fastcgi_params;
    }
}
NGINX
    elif [ "$type" = "proxy" ]; then
        read -p "代理目标 (如 http://127.0.0.1:3000): " target
        cat >> "$conf_path" << NGINX

    location / {
        proxy_pass $target;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
    }
}
NGINX
    elif [ "$type" = "node" ] || [ "$type" = "pm2" ] || [ "$type" = "python" ] || [ "$type" = "docker" ]; then
        # 获取可用端口
        local port=$(find_available_port 3000)
        [ "$type" = "python" ] && port=$(find_available_port 8000)

        cat >> "$conf_path" << NGINX

    location / {
        proxy_pass http://127.0.0.1:$port;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }
}
NGINX
        # 创建应用配置
        _setup_app_site "$domain" "$type" "$port"
    else
        cat >> "$conf_path" << 'NGINX'

    location / {
        try_files $uri $uri/ /index.html;
    }
}
NGINX
    fi

    ln -sf "$conf_path" "$NGINX_ENABLED_DIR/$domain"

    # 安全测试并重载，失败时回滚
    if nginx_safe_reload "$conf_path" "$NGINX_ENABLED_DIR/$domain"; then
        echo -e "${GREEN}站点 $domain 创建成功 (${type}${php_version:+ $php_version})${NC}"
    else
        # 清理站点目录
        [ -d "$site_path" ] && rm -rf "$site_path"
        echo -e "${RED}站点创建失败${NC}"
        return 1
    fi
}
# 内部删除函数 - 可被 CLI 和交互式菜单调用
# 用法: _do_site_delete <域名> <模式> [--yes]
# 模式: config (仅配置), full (配置+文件), backup (备份后删除)
_do_site_delete() {
    local domain="$1"
    local mode="$2"
    local skip_confirm="$3"

    validate_domain "$domain" || return 1

    local conf_path="$NGINX_CONF_DIR/$domain"
    local enabled_path="$NGINX_ENABLED_DIR/$domain"
    local site_path="$SITES_DIR/$domain"

    [ ! -f "$conf_path" ] && echo -e "${RED}站点不存在: $domain${NC}" && return 1

    case "$mode" in
        config)
            # 仅删除配置
            rm -f "$enabled_path" "$conf_path"
            if nginx_safe_reload; then
                echo -e "${GREEN}配置已删除 (文件保留在 $site_path)${NC}"
            else
                echo -e "${RED}Nginx 重载失败，配置已删除但可能需要手动处理${NC}"
                return 1
            fi
            ;;
        full)
            # 删除配置和文件
            if [ "$skip_confirm" != "--yes" ]; then
                read -p "确认删除配置和所有文件? (输入 'yes' 确认): " confirm
                [ "$confirm" != "yes" ] && echo "已取消" && return 0
            fi
            rm -f "$enabled_path" "$conf_path"
            [ -d "$site_path" ] && rm -rf "$site_path"
            rm -f "$LOGS_DIR/${domain}_access.log" "$LOGS_DIR/${domain}_error.log"
            if nginx_safe_reload; then
                echo -e "${GREEN}站点已完全删除: $domain${NC}"
            else
                echo -e "${RED}Nginx 重载失败，但文件已删除${NC}"
                return 1
            fi
            ;;
        backup)
            # 备份后删除
            local backup_file="$BACKUP_DIR/${domain}_$(date +%Y%m%d_%H%M%S).tar.gz"
            mkdir -p "$BACKUP_DIR"
            echo "正在备份..."
            if [ -d "$site_path" ]; then
                if tar -czf "$backup_file" -C "$(dirname "$site_path")" "$(basename "$site_path")" 2>/dev/null; then
                    echo -e "${GREEN}备份成功: $backup_file${NC}"
                else
                    echo -e "${RED}备份失败，操作已取消${NC}"
                    return 1
                fi
            fi
            rm -f "$enabled_path" "$conf_path"
            [ -d "$site_path" ] && rm -rf "$site_path"
            rm -f "$LOGS_DIR/${domain}_access.log" "$LOGS_DIR/${domain}_error.log"
            if nginx_safe_reload; then
                echo -e "${GREEN}站点已删除: $domain${NC}"
            else
                echo -e "${RED}Nginx 重载失败，但备份和文件删除已完成${NC}"
                return 1
            fi
            ;;
        *)
            echo -e "${RED}无效模式: $mode (支持: config, full, backup)${NC}"
            return 1
            ;;
    esac
}

# 交互式删除 - 菜单调用
site_delete() {
    site_list
    read -p "域名: " domain
    [ -z "$domain" ] && return

    validate_domain "$domain" || return 1

    local conf_path="$NGINX_CONF_DIR/$domain"
    local site_path="$SITES_DIR/$domain"

    [ ! -f "$conf_path" ] && echo -e "${RED}站点不存在${NC}" && return

    echo ""
    echo -e "${YELLOW}即将删除站点: $domain${NC}"
    echo " 配置文件: $conf_path"
    [ -d "$site_path" ] && echo " 站点目录: $site_path ($(du -sh "$site_path" 2>/dev/null | cut -f1))"
    echo ""
    echo " 1) 仅删除配置 (保留文件)"
    echo " 2) 删除配置和站点文件"
    echo " 3) 备份后删除全部"
    echo " 0) 取消"
    read -p "选择: " choice

    case "$choice" in
        1) _do_site_delete "$domain" "config";;
        2) _do_site_delete "$domain" "full";;
        3) _do_site_delete "$domain" "backup";;
        *) echo "已取消";;
    esac
}

site_enable() {
    local domain="$1"

    # 验证域名格式
    validate_domain "$domain" || return 1

    # 检查配置文件是否存在
    if [ ! -f "$NGINX_CONF_DIR/$domain" ]; then
        echo -e "${RED}站点配置不存在: $NGINX_CONF_DIR/$domain${NC}"
        return 1
    fi

    # 创建符号链接
    ln -sf "$NGINX_CONF_DIR/$domain" "$NGINX_ENABLED_DIR/$domain"

    # 测试 nginx 配置
    if ! nginx -t 2>/dev/null; then
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5
        rm -f "$NGINX_ENABLED_DIR/$domain"
        echo -e "${YELLOW}已移除符号链接，请检查站点配置${NC}"
        return 1
    fi

    # 重载 nginx
    if systemctl reload nginx; then
        echo -e "${GREEN}$domain 已启用${NC}"
    else
        echo -e "${RED}Nginx 重载失败${NC}"
        rm -f "$NGINX_ENABLED_DIR/$domain"
        return 1
    fi
}

site_disable() {
    local domain="$1"
    local link_target=""

    # 验证域名格式
    validate_domain "$domain" || return 1

    # 检查符号链接是否存在
    if [ ! -L "$NGINX_ENABLED_DIR/$domain" ]; then
        echo -e "${YELLOW}站点未启用或链接不存在${NC}"
        return 0
    fi

    # 保存原链接目标以便回滚
    link_target=$(readlink -f "$NGINX_ENABLED_DIR/$domain" 2>/dev/null)

    # 移除符号链接
    rm -f "$NGINX_ENABLED_DIR/$domain"

    # 测试 nginx 配置
    if ! nginx -t 2>/dev/null; then
        echo -e "${RED}Nginx 配置测试失败，正在回滚...${NC}"
        nginx -t 2>&1 | head -5
        # 恢复符号链接
        if [ -n "$link_target" ] && [ -f "$link_target" ]; then
            ln -sf "$link_target" "$NGINX_ENABLED_DIR/$domain"
            echo -e "${YELLOW}已恢复符号链接，请检查 Nginx 配置${NC}"
        fi
        return 1
    fi

    # 重载 nginx
    if systemctl reload nginx; then
        echo -e "${GREEN}$domain 已禁用${NC}"
    else
        echo -e "${RED}Nginx 重载失败${NC}"
        # 恢复符号链接
        if [ -n "$link_target" ] && [ -f "$link_target" ]; then
            ln -sf "$link_target" "$NGINX_ENABLED_DIR/$domain"
        fi
        return 1
    fi
}

site_info() {
    local domain="$1"
    local conf="$NGINX_CONF_DIR/$domain"
    [ ! -f "$conf" ] && echo -e "${RED}站点不存在${NC}" && return
    echo ""
    echo -e "域名: $domain"
    echo -e "目录: $SITES_DIR/$domain"
    echo -e "大小: $(du -sh "$SITES_DIR/$domain" 2>/dev/null | awk '{print $1}')"
    echo -e "配置: $conf"
    grep -q "ssl_certificate" "$conf" && echo -e "SSL:  ${GREEN}已启用${NC}" || echo -e "SSL:  未配置"
    echo ""
}

# SSL 函数已移至 lib/ssl.sh

# ================== 软件管理 ==================
# ================== 软件管理 ==================
SOFTWARE_DIR="/opt/site_manager/software"
SOFTWARE_LIST="$SOFTWARE_DIR/list.json"

software_menu() {
    echo ""
    echo -e "${CYAN}======== 软件管理 ========${NC}"
    echo " 1) 查看已安装软件"
    echo " 2) 安装软件"
    echo " 3) 卸载软件"
    echo " 4) 服务管理"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) soft_list;;
        2) soft_install;;
        3) soft_uninstall;;
        4) service_menu;;
    esac
}

soft_list() {
    echo ""
    printf "%-12s %-10s %-10s %s\n" "软件" "版本" "状态" "描述"
    printf "%-12s %-10s %-10s %s\n" "----" "----" "----" "----"
    
    # 检查各软件状态
    local items=("nginx:/usr/sbin/nginx" "php:/usr/bin/php" "mysql:/usr/bin/mysql" "redis:/usr/bin/redis-server" "nodejs:/usr/bin/node" "docker:/usr/bin/docker" "composer:/usr/local/bin/composer")
    
    for item in "${items[@]}"; do
        local name="${item%%:*}"
        local check="${item##*:}"
        local version="-"
        local status="${RED}未安装${NC}"
        
        if [ -f "$check" ] || [ -x "$check" ]; then
            status="${GREEN}已安装${NC}"
            case "$name" in
                nginx) version=$(nginx -v 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                php) version=$(php -v 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                mysql) version=$(mysql --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1);;
                redis) version=$(redis-server --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                nodejs) version=$(node --version 2>/dev/null | tr -d 'v');;
                docker) version=$(docker --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
                composer) version=$(composer --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+');;
            esac
        fi
        printf "%-12s %-10s %-10b\n" "$name" "${version:-?}" "$status"
    done
    echo ""
}

soft_install() {
    echo ""
    echo -e "${CYAN}可安装的软件:${NC}"
    echo " 1) nginx    - Web服务器"
    echo " 2) php      - PHP语言"
    echo " 3) mysql    - MySQL数据库"
    echo " 4) redis    - Redis缓存"
    echo " 5) nodejs   - Node.js运行时"
    echo " 6) docker   - Docker容器"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    
    local script=""
    local version=""
    case "$c" in
        1) script="nginx.sh"; echo "可用版本: 1.24, 1.26, 1.27"; read -p "版本[1.26]: " version; version="${version:-1.26}";;
        2) script="php.sh"; echo "可用版本: 7.4, 8.0, 8.1, 8.2, 8.3"; read -p "版本[8.2]: " version; version="${version:-8.2}";;
        3) script="mysql.sh"; echo "可用版本: 5.7, 8.0, 8.4"; read -p "版本[8.0]: " version; version="${version:-8.0}";;
        4) script="redis.sh";;
        5) script="nodejs.sh"; echo "可用版本: 18, 20, 22"; read -p "版本[20]: " version; version="${version:-20}";;
        6) script="docker.sh";;
        0|*) return;;
    esac
    
    if [ -n "$script" ] && [ -f "$SOFTWARE_DIR/install/$script" ]; then
        bash "$SOFTWARE_DIR/install/$script" install "$version"
    else
        echo -e "${RED}安装脚本不存在${NC}"
    fi
}

soft_uninstall() {
    echo ""
    echo -e "${YELLOW}选择要卸载的软件:${NC}"
    echo " 1) nginx  2) php  3) mysql  4) redis  5) nodejs  6) docker"
    read -p "选择: " c
    
    local script=""
    case "$c" in
        1) script="nginx.sh";; 2) script="php.sh";; 3) script="mysql.sh";;
        4) script="redis.sh";; 5) script="nodejs.sh";; 6) script="docker.sh";;
        *) return;;
    esac
    
    if [ -n "$script" ] && [ -f "$SOFTWARE_DIR/install/$script" ]; then
        bash "$SOFTWARE_DIR/install/$script" uninstall
    fi
}

service_menu() {
    echo ""
    echo -e "${CYAN}======== 服务管理 ========${NC}"
    echo " 1) Nginx (重载/重启/状态)"
    echo " 2) PHP-FPM (重启/状态)"
    echo " 3) MySQL (重启/状态)"
    echo " 4) Redis (重启/状态)"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) nginx_ctl;;
        2) php_ctl;;
        3) mysql_ctl;;
        4) redis_ctl;;
    esac
}
# ================== 备份管理 ==================
# ================== 备份配置 ==================
BACKUP_CONF="/opt/site_manager/config/backup.conf"
EXCLUDE_CONF="/opt/site_manager/config/backup_exclude.conf"
[ -f "$BACKUP_CONF" ] && source "$BACKUP_CONF"
BACKUP_DIR="${BACKUP_DIR:-/www/backup}"
BACKUP_KEEP="${BACKUP_KEEP:-7}"
DB_KEEP="${DB_KEEP:-51}"
SITE_KEEP="${SITE_KEEP:-7}"

# 备份子目录
DB_BACKUP_DIR="$BACKUP_DIR/database"
SITE_BACKUP_DIR="$BACKUP_DIR/site"
PATH_BACKUP_DIR="$BACKUP_DIR/path"

# ================== 备份管理 ==================
backup_menu() {
    echo ""
    echo -e "${CYAN}======== 备份管理 ========${NC}"
    echo " 1) 备份站点"
    echo " 2) 恢复站点"
    echo " 3) 备份数据库"
    echo " 4) 恢复数据库"
    echo " 5) 查看备份"
    echo " 6) 备份设置"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) backup_site;;
        2) restore_site;;
        3) backup_db;;
        4) restore_db;;
        5) list_backups;;
        6) backup_settings;;
    esac
}

# 生成排除参数
get_exclude_args() {
    local args=""
    if [ -f "$EXCLUDE_CONF" ]; then
        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            args="$args --exclude=$line"
        done < "$EXCLUDE_CONF"
    fi
    echo "$args"
}

# 上传到 FTP (支持子目录)
upload_to_ftp() {
    local file="$1"
    local subdir="${2:-}"
    [ "$FTP_ENABLED" != "true" ] && return 0
    [ -z "$FTP_HOST" ] && return 0

    local remote_path="${FTP_PATH}"
    [ -n "$subdir" ] && remote_path="${FTP_PATH}/${subdir}"

    echo -e "${CYAN}上传到 FTP: $(basename "$file")${NC}"

    curl -s -T "$file" "ftp://${FTP_HOST}:${FTP_PORT}${remote_path}/$(basename "$file")" \
        --user "${FTP_USER}:${FTP_PASS}" \
        --ftp-create-dirs 2>/dev/null

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}FTP上传成功${NC}"
        [ "$FTP_DELETE_LOCAL" = "true" ] && rm -f "$file" && echo "本地文件已删除"
        return 0
    else
        echo -e "${RED}FTP上传失败${NC}"
        return 1
    fi
}

# 清理旧备份
# 用法: cleanup_backups <pattern> [backup_dir] [keep_count]
cleanup_backups() {
    local pattern="$1"
    local backup_dir="${2:-$BACKUP_DIR}"
    local keep="${3:-${BACKUP_KEEP:-7}}"

    # 安全检查：确保 pattern 不为空
    [ -z "$pattern" ] && return 1

    # 安全检查：确保 backup_dir 存在且不为空
    [ -z "$backup_dir" ] && return 1
    [ ! -d "$backup_dir" ] && return 0

    # 本地清理
    local files=()
    while IFS= read -r -d '' f; do
        files+=("$f")
    done < <(find "$backup_dir" -maxdepth 1 -name "${pattern}*" -type f -print0 2>/dev/null | sort -z -r)

    local count=${#files[@]}
    if [ "$count" -gt "$keep" ]; then
        local deleted=0
        for ((i=keep; i<count; i++)); do
            rm -f "${files[$i]}" && ((deleted++))
        done
        [ "$deleted" -gt 0 ] && echo -e "${CYAN}已清理 $deleted 个旧备份，保留最新 $keep 份${NC}"
    fi
}

backup_site() {
    echo ""
    echo -e "${CYAN}选择要备份的站点:${NC}"

    local i=1
    local sites=()
    for conf in "$NGINX_CONF_DIR"/*; do
        [ -f "$conf" ] || continue
        local name=$(basename "$conf")
        [[ "$name" == "default" || "$name" == *.bak ]] && continue
        local domain="${name%.conf}"
        sites+=("$domain")
        printf " %2d) %s\n" $i "$domain"
        ((i++))
    done

    [ ${#sites[@]} -eq 0 ] && echo "无站点" && return
    echo "  a) 备份全部"
    echo "  0) 返回"
    echo ""
    read -p "编号: " n

    mkdir -p "$SITE_BACKUP_DIR"

    # 检查磁盘空间 (至少保留 500MB)
    local avail=$(df -m "$SITE_BACKUP_DIR" 2>/dev/null | awk 'NR==2 {print $4}')
    if [ -n "$avail" ] && [ "$avail" -lt 500 ]; then
        echo -e "${RED}磁盘空间不足 (剩余 ${avail}MB)，请先清理${NC}"
        return 1
    fi

    local exclude_args=$(get_exclude_args)

    if [ "$n" = "a" ]; then
        local success=0 fail=0
        for d in "${sites[@]}"; do
            local file="$SITE_BACKUP_DIR/${d}_$(date +%Y%m%d_%H%M%S).tar.gz"
            if [ ! -d "$SITES_DIR/$d" ]; then
                echo -e "${YELLOW}跳过: $d (目录不存在)${NC}"
                ((fail++))
                continue
            fi
            if tar -czf "$file" $exclude_args -C "$SITES_DIR" "$d" 2>/dev/null; then
                echo -e "${GREEN}备份成功: $d ($(du -h "$file" | cut -f1))${NC}"
                upload_to_ftp "$file" "site"
                cleanup_backups "${d}_" "$SITE_BACKUP_DIR" "$SITE_KEEP"
                ((success++))
            else
                echo -e "${RED}备份失败: $d${NC}"
                rm -f "$file"
                ((fail++))
            fi
        done
        echo -e "\n备份完成: ${GREEN}成功 $success${NC}, ${RED}失败 $fail${NC}"
        return
    fi

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#sites[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local d="${sites[$((n-1))]}"
    local file="$SITE_BACKUP_DIR/${d}_$(date +%Y%m%d_%H%M%S).tar.gz"

    if [ ! -d "$SITES_DIR/$d" ]; then
        echo -e "${RED}站点目录不存在: $SITES_DIR/$d${NC}"
        return 1
    fi

    if tar -czf "$file" $exclude_args -C "$SITES_DIR" "$d" 2>/dev/null; then
        echo -e "${GREEN}备份成功: $file ($(du -h "$file" | cut -f1))${NC}"
        upload_to_ftp "$file" "site"
        cleanup_backups "${d}_" "$SITE_BACKUP_DIR" "$SITE_KEEP"
    else
        echo -e "${RED}备份失败${NC}"
        rm -f "$file"
        return 1
    fi
}

restore_site() {
    echo ""
    echo -e "${CYAN}选择要恢复的备份:${NC}"

    local i=1
    local files=()
    for f in "$SITE_BACKUP_DIR"/*.tar.gz "$BACKUP_DIR"/*.tar.gz; do
        [ -f "$f" ] || continue
        files+=("$f")
        printf " %2d) %s\n" $i "$(basename "$f")"
        ((i++))
    done

    [ ${#files[@]} -eq 0 ] && echo "无备份" && return
    echo "  0) 返回"
    echo ""
    read -p "编号: " n

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#files[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local f="${files[$((n-1))]}"
    tar -xzf "$f" -C "$SITES_DIR" && echo -e "${GREEN}恢复成功${NC}"
}

backup_db() {
    echo ""
    echo -e "${CYAN}选择要备份的数据库:${NC}"

    local i=1
    local dbs=()
    while read -r db; do
        [[ "$db" =~ ^(Database|information_schema|performance_schema|mysql|sys)$ ]] && continue
        dbs+=("$db")
        printf " %2d) %s\n" $i "$db"
        ((i++))
    done < <(mysql_exec -N -e "SHOW DATABASES;")

    [ ${#dbs[@]} -eq 0 ] && echo -e "${RED}无数据库或无法连接 MySQL${NC}" && return
    echo "  a) 备份全部"
    echo "  0) 返回"
    echo ""
    read -p "编号: " n

    mkdir -p "$DB_BACKUP_DIR"

    if [ "$n" = "a" ]; then
        local success=0 fail=0
        for db in "${dbs[@]}"; do
            local file="$DB_BACKUP_DIR/${db}_$(date +%Y%m%d_%H%M%S).sql"
            if mysqldump_exec "$db" "$file"; then
                echo -e "${GREEN}备份成功: $db${NC}"
                upload_to_ftp "$file" "database"
                cleanup_backups "${db}_" "$DB_BACKUP_DIR" "$DB_KEEP"
                ((success++))
            else
                ((fail++))
            fi
        done
        echo -e "\n备份完成: ${GREEN}成功 $success${NC}, ${RED}失败 $fail${NC}"
        return
    fi

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#dbs[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local db="${dbs[$((n-1))]}"
    local file="$DB_BACKUP_DIR/${db}_$(date +%Y%m%d_%H%M%S).sql"
    if mysqldump_exec "$db" "$file"; then
        echo -e "${GREEN}备份成功: $file${NC}"
        upload_to_ftp "$file" "database"
        cleanup_backups "${db}_" "$DB_BACKUP_DIR" "$DB_KEEP"
    fi
}

restore_db() {
    echo ""
    echo -e "${CYAN}选择要恢复的备份:${NC}"

    local i=1
    local files=()
    for f in "$DB_BACKUP_DIR"/*.sql "$BACKUP_DIR"/*.sql; do
        [ -f "$f" ] || continue
        files+=("$f")
        printf " %2d) %s ($(du -h "$f" | cut -f1))\n" $i "$(basename "$f")"
        ((i++))
    done

    [ ${#files[@]} -eq 0 ] && echo "无SQL备份" && return
    echo "  0) 返回"
    echo ""
    read -p "编号: " n

    if [[ ! "$n" =~ ^[0-9]+$ ]] || [ "$n" -eq 0 ]; then return; fi
    [ "$n" -gt ${#files[@]} ] && echo -e "${RED}无效编号${NC}" && return

    local f="${files[$((n-1))]}"
    local dbname=$(basename "$f" .sql | sed 's/_[0-9]*$//' | sed 's/_[0-9]*$//')
    read -p "数据库名 [$dbname]: " input_db
    dbname="${input_db:-$dbname}"

    echo "正在恢复..."
    if mysql_exec "$dbname" < "$f"; then
        echo -e "${GREEN}恢复成功: $dbname${NC}"
    else
        echo -e "${RED}恢复失败，请检查数据库是否存在或凭据是否正确${NC}"
        return 1
    fi
}

list_backups() {
    echo ""
    echo -e "${CYAN}======== 本地备份 ========${NC}"

    # 数据库备份
    echo -e "\n${YELLOW}[数据库备份]${NC} $DB_BACKUP_DIR (保留 $DB_KEEP 份)"
    if [ -d "$DB_BACKUP_DIR" ] && [ "$(ls -A "$DB_BACKUP_DIR" 2>/dev/null)" ]; then
        ls -lh "$DB_BACKUP_DIR" 2>/dev/null | grep -v ^total | head -10
        local db_count=$(ls "$DB_BACKUP_DIR"/*.sql 2>/dev/null | wc -l)
        [ "$db_count" -gt 10 ] && echo -e "  ... 共 $db_count 个文件"
    else
        echo "  无备份"
    fi

    # 站点备份
    echo -e "\n${YELLOW}[站点备份]${NC} $SITE_BACKUP_DIR (保留 $SITE_KEEP 份)"
    if [ -d "$SITE_BACKUP_DIR" ] && [ "$(ls -A "$SITE_BACKUP_DIR" 2>/dev/null)" ]; then
        ls -lh "$SITE_BACKUP_DIR" 2>/dev/null | grep -v ^total | head -10
        local site_count=$(ls "$SITE_BACKUP_DIR"/*.tar.gz 2>/dev/null | wc -l)
        [ "$site_count" -gt 10 ] && echo -e "  ... 共 $site_count 个文件"
    else
        echo "  无备份"
    fi

    # 路径备份
    if [ -d "$PATH_BACKUP_DIR" ] && [ "$(ls -A "$PATH_BACKUP_DIR" 2>/dev/null)" ]; then
        echo -e "\n${YELLOW}[路径备份]${NC} $PATH_BACKUP_DIR"
        ls -lh "$PATH_BACKUP_DIR" 2>/dev/null | grep -v ^total | head -10
    fi

    # 旧备份 (根目录)
    local old_count=$(ls "$BACKUP_DIR"/*.sql "$BACKUP_DIR"/*.tar.gz 2>/dev/null | wc -l)
    if [ "$old_count" -gt 0 ]; then
        echo -e "\n${YELLOW}[旧备份]${NC} $BACKUP_DIR (待迁移)"
        ls -lh "$BACKUP_DIR"/*.sql "$BACKUP_DIR"/*.tar.gz 2>/dev/null | head -5
        [ "$old_count" -gt 5 ] && echo -e "  ... 共 $old_count 个文件"
    fi

    if [ "$FTP_ENABLED" = "true" ]; then
        echo ""
        echo -e "${CYAN}======== FTP远程备份 ========${NC}"
        echo -e "服务器: ${FTP_HOST}:${FTP_PORT}"
        echo -e "路径: ${FTP_PATH}/database, ${FTP_PATH}/site"
    fi
}

backup_settings() {
    echo ""
    echo -e "${CYAN}======== 备份设置 ========${NC}"
    echo -e " 备份根目录: $BACKUP_DIR"
    echo -e "   数据库:   $DB_BACKUP_DIR (保留 $DB_KEEP 份)"
    echo -e "   站点:     $SITE_BACKUP_DIR (保留 $SITE_KEEP 份)"
    echo -e "   路径:     $PATH_BACKUP_DIR"
    echo -e " FTP备份:  $([ "$FTP_ENABLED" = "true" ] && echo -e "${GREEN}已开启${NC}" || echo -e "${RED}未开启${NC}")"
    [ "$FTP_ENABLED" = "true" ] && echo -e " FTP服务器: $FTP_HOST:$FTP_PORT${FTP_PATH}"
    echo ""
    echo " 1) 设置数据库保留份数"
    echo " 2) 设置站点保留份数"
    echo " 3) 配置FTP"
    echo " 4) 测试FTP连接"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) set_db_keep;;
        2) set_site_keep;;
        3) set_ftp_config;;
        4) test_ftp;;
    esac
}

set_db_keep() {
    read -p "数据库备份保留份数 [$DB_KEEP]: " n
    [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt 0 ] || return
    if grep -q "^DB_KEEP=" "$BACKUP_CONF" 2>/dev/null; then
        sed -i "s/^DB_KEEP=.*/DB_KEEP=$n/" "$BACKUP_CONF"
    else
        echo "DB_KEEP=$n" >> "$BACKUP_CONF"
    fi
    DB_KEEP=$n
    echo -e "${GREEN}已设置数据库备份保留 $n 份${NC}"
}

set_site_keep() {
    read -p "站点备份保留份数 [$SITE_KEEP]: " n
    [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt 0 ] || return
    if grep -q "^SITE_KEEP=" "$BACKUP_CONF" 2>/dev/null; then
        sed -i "s/^SITE_KEEP=.*/SITE_KEEP=$n/" "$BACKUP_CONF"
    else
        echo "SITE_KEEP=$n" >> "$BACKUP_CONF"
    fi
    SITE_KEEP=$n
    echo -e "${GREEN}已设置站点备份保留 $n 份${NC}"
}

set_ftp_config() {
    echo ""
    echo -e "${CYAN}配置FTP远程备份${NC}"
    read -p "FTP服务器地址: " host
    read -p "FTP端口 [21]: " port
    port="${port:-21}"
    read -p "FTP用户名: " user
    read -s -p "FTP密码: " pass
    echo ""
    read -p "远程目录 [/backup]: " path
    path="${path:-/backup}"
    read -p "上传后删除本地文件? (y/n) [n]: " del
    del="$([ "$del" = "y" ] && echo "true" || echo "false")"
    
    # 保存配置
    cat > "$BACKUP_CONF" << CONF
# 备份配置
BACKUP_DIR="$BACKUP_DIR"
BACKUP_KEEP=$BACKUP_KEEP

# FTP配置
FTP_ENABLED=true
FTP_HOST="$host"
FTP_PORT=$port
FTP_USER="$user"
FTP_PASS="$pass"
FTP_PATH="$path"
FTP_DELETE_LOCAL=$del
CONF
    chmod 600 "$BACKUP_CONF"
    source "$BACKUP_CONF"
    echo -e "${GREEN}FTP配置已保存${NC}"
}

test_ftp() {
    [ "$FTP_ENABLED" != "true" ] && echo -e "${YELLOW}FTP未配置${NC}" && return
    
    echo "测试连接 $FTP_HOST..."
    echo "test" > /tmp/ftp_test.txt
    curl -s -T /tmp/ftp_test.txt "ftp://${FTP_HOST}:${FTP_PORT}${FTP_PATH}/ftp_test.txt" \
        --user "${FTP_USER}:${FTP_PASS}" --ftp-create-dirs 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}FTP连接成功!${NC}"
        # 删除测试文件
        curl -s "ftp://${FTP_HOST}:${FTP_PORT}" --user "${FTP_USER}:${FTP_PASS}" \
            -Q "DELE ${FTP_PATH}/ftp_test.txt" 2>/dev/null
    else
        echo -e "${RED}FTP连接失败${NC}"
    fi
    rm -f /tmp/ftp_test.txt
}

# ================== 安全管理 ==================
security_menu() {
    echo ""
    echo -e "${CYAN}======== 安全管理 ========${NC}"
    echo " 1) 防火墙状态"
    echo " 2) 开启防火墙"
    echo " 3) 关闭防火墙"
    echo " 4) 放行端口"
    echo " 5) 封禁端口"
    echo " 6) 删除规则"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) ufw status numbered;;
        2) ufw --force enable && echo -e "${GREEN}已开启${NC}";;
        3) ufw disable && echo -e "${GREEN}已关闭${NC}";;
        4) read -p "端口: " p; ufw allow "$p/tcp" && echo -e "${GREEN}已放行${NC}";;
        5) read -p "端口: " p; ufw deny "$p/tcp" && echo -e "${GREEN}已封禁${NC}";;
        6) ufw status numbered; read -p "规则编号: " n; echo y | ufw delete "$n";;
    esac
}

# ================== 系统信息 ==================
system_menu() {
    echo ""
    echo -e "${CYAN}======== 系统信息 ========${NC}"
    echo " 1) 系统概览"
    echo " 2) 磁盘使用"
    echo " 3) 内存使用"
    echo " 4) 网络连接"
    echo " 5) 进程列表"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) sys_overview;;
        2) df -h | grep -E "^/dev|^Filesystem";;
        3) free -h;;
        4) ss -tlnp | head -20;;
        5) ps aux --sort=-%cpu | head -15;;
    esac
}

sys_overview() {
    echo ""
    echo -e " 主机: $(hostname)"
    echo -e " 系统: $(grep PRETTY_NAME /etc/os-release | cut -d'"' -f2)"
    echo -e " 内核: $(uname -r)"
    echo -e " CPU:  $(nproc) 核"
    echo -e " 内存: $(free -h | awk '/Mem:/{printf "%s/%s", $3, $2}')"
    echo -e " 磁盘: $(df -h / | awk 'NR==2{printf "%s/%s (%s)", $3, $2, $5}')"
    echo -e " 负载: $(cat /proc/loadavg | awk '{print $1, $2, $3}')"
    echo -e " 运行: $(uptime -p)"
}

# ================== Web面板 ==================
panel_menu() {
    local status="${RED}已停止${NC}"
    pgrep -f "site_manager_panel" > /dev/null && status="${GREEN}运行中${NC}"
    echo ""
    echo -e "${CYAN}======== Web面板 ========${NC}"
    echo -e " 状态: $status"
    echo ""
    echo " 1) 启动"
    echo " 2) 停止"
    echo " 3) 重启"
    echo " 4) 修改端口"
    echo " 5) 重置密码"
    echo " 0) 返回"
    echo ""
    read -p "选择: " c
    case "$c" in
        1) panel_start;;
        2) panel_stop;;
        3) panel_stop; sleep 1; panel_start;;
        4) panel_port;;
        5) panel_password;;
    esac
}

panel_start() {
    pgrep -f "site_manager_panel" > /dev/null && echo -e "${YELLOW}已在运行${NC}" && return
    local port=$([ -f "$PANEL_CONFIG" ] && grep -o '"port":[[:space:]]*[0-9]*' "$PANEL_CONFIG" | grep -o '[0-9]*' || echo "8888")
    cd "$PANEL_DIR" && nohup "$PANEL_BIN" -port "$port" > /tmp/panel.log 2>&1 &
    sleep 2
    local ip=$(curl -s --connect-timeout 2 ifconfig.me 2>/dev/null || hostname -I | awk '{print $1}')
    echo -e "${GREEN}已启动: http://$ip:$port${NC}"
}

panel_stop() {
    pkill -f "site_manager_panel" && echo -e "${GREEN}已停止${NC}" || echo -e "${YELLOW}未运行${NC}"
}

panel_port() {
    local port=$([ -f "$PANEL_CONFIG" ] && grep -o '"port":[[:space:]]*[0-9]*' "$PANEL_CONFIG" | grep -o '[0-9]*' || echo "8888")
    echo "当前端口: $port"
    read -p "新端口: " p
    [[ "$p" =~ ^[0-9]+$ ]] && [ "$p" -ge 1024 ] || { echo -e "${RED}无效${NC}"; return; }
    [ -f "$PANEL_CONFIG" ] && sed -i "s/\"port\":[[:space:]]*[0-9]*/\"port\": $p/" "$PANEL_CONFIG"
    ufw allow "$p/tcp" 2>/dev/null
    echo -e "${GREEN}已改为 $p，请重启面板${NC}"
}

panel_password() {
    [ ! -f "$PANEL_DB" ] && echo -e "${RED}数据库不存在${NC}" && return
    local pass=$(tr -dc 'A-Za-z0-9' < /dev/urandom | head -c 16)
    if command -v python3 &>/dev/null; then
        local hash=$(python3 -c "import bcrypt; print(bcrypt.hashpw('$pass'.encode(), bcrypt.gensalt()).decode())" 2>/dev/null)
        [ -n "$hash" ] && sqlite3 "$PANEL_DB" "UPDATE users SET password='$hash' WHERE username='admin';"
        echo -e "${GREEN}新密码: $pass${NC}"
    else
        echo -e "${YELLOW}需要 python3-bcrypt${NC}"
    fi
}

# ================== 命令行接口 ==================
show_help() {
    echo ""
    echo -e "${GREEN}Site Manager v$VERSION${NC}"
    echo ""
    echo "用法: site [命令] [参数]"
    echo ""
    echo "交互模式:"
    echo "  site -m                 进入交互式菜单"
    echo ""
    echo "站点管理:"
    echo "  site list               查看所有站点"
    echo "  site create <域名> <类型>  创建站点 (php73/php80/php83/static/node/pm2/python/docker/proxy)"
    echo "  site delete <域名> [--config|--full|--backup]  删除站点"
    echo "  site enable <域名>      启用站点"
    echo "  site disable <域名>     禁用站点"
    echo "  site info <域名>        站点详情"
    echo "  site rewrite            查看可用伪静态规则"
    echo "  site rewrite <域名>     设置站点伪静态 (交互式)"
    echo "  site rewrite <域名> <规则>  设置站点伪静态"
    echo ""
    echo "SSL证书:"
    echo "  site ssl <域名> [--dns] [--wildcard]  申请证书"
    echo "  site ssl account list/add/remove     管理DNS账号"
    echo "  site ssl bind <域名> <账号>          绑定域名到账号"
    echo "  site ssl list                        查看证书状态"
    echo "  site ssl renew                       续期证书(>30天跳过)"
    echo ""
    echo "备份恢复:"
    echo "  site backup site [域名]   备份站点 (不指定则备份全部)"
    echo "  site backup db [库名]     备份数据库 (不指定则备份全部)"
    echo "  site backup path <路径>   备份指定目录"
    echo "  site backup list          查看备份列表"
    echo "  site backup config        查看/修改备份配置"
    echo "  site restore <域名> <文件>  恢复站点"
    echo "  site db restore <库> <文件>  恢复数据库"
    echo ""
    echo "软件管理:"
    echo "  site soft               查看已安装软件"
    echo "  site install <软件> [版本]  安装软件"
    echo "  site uninstall <软件>   卸载软件"
    echo "    可用软件: nginx, php, mysql, redis, nodejs, docker"
    echo ""
    echo "服务管理:"
    echo "  site nginx reload|restart|status"
    echo "  site php restart"
    echo "  site mysql restart|status"
    echo "  site redis restart|status"
    echo ""
    echo "计划任务:"
    echo "  site cron list              查看计划任务"
    echo "  site cron add \"<时间>\" \"<命令>\"  添加任务 (自动包装日志)"
    echo "  site cron remove <编号>     删除任务"
    echo "  site cron log [行数]        查看任务日志"
    echo ""
    # 进程管理 (仅已安装时显示)
    if command -v supervisorctl &>/dev/null; then
        echo "进程管理:"
        echo "  site supervisor status  查看进程状态"
        echo "  site supervisor start|stop|restart <app>"
        echo "  site supervisor reload  重载配置"
        echo "  site supervisor add <名称> <命令> [目录] [用户]"
        echo "  site supervisor remove <app>"
        echo ""
    fi
    echo "安全管理:"
    echo "  site firewall status|on|off"
    echo "  site firewall allow <端口>"
    echo "  site firewall deny <端口>"
    echo ""
    echo "Web面板:"
    echo "  site panel start|stop|restart"
    echo ""
}

# ================== 命令行处理 ==================
handle_cli() {
    case "$1" in
        list) site_list;;
        create) [ -n "$2" ] && [ -n "$3" ] && {
            domain="$2"; type_arg="$3"
            local type="" php_version="" port=""
            # 解析类型参数
            if [[ "$type_arg" =~ ^php([0-9])([0-9]+)$ ]]; then
                type="php"
                php_version="${BASH_REMATCH[1]}.${BASH_REMATCH[2]}"
            elif [[ "$type_arg" == "static" ]]; then
                type="static"
            elif [[ "$type_arg" == "node" ]]; then
                type="node"
            elif [[ "$type_arg" == "pm2" ]]; then
                type="pm2"
            elif [[ "$type_arg" == "python" ]]; then
                type="python"
            elif [[ "$type_arg" == "docker" ]]; then
                type="docker"
            elif [[ "$type_arg" == "proxy" ]]; then
                type="proxy"
            else
                echo "无效类型: $type_arg (支持: php73/php80/php83/static/node/pm2/python/docker/proxy)"
                exit 1
            fi
            _do_site_create "$domain" "$type" "$php_version"
        } || echo "用法: site create <域名> <类型> (php73/php80/php83/static/node/pm2/python/docker/proxy)";;
        delete)
            if [ -z "$2" ]; then
                echo "用法: site delete <域名> [选项]"
                echo "选项:"
                echo "  --config     仅删除配置 (保留文件)"
                echo "  --full       删除配置和站点文件 (需确认)"
                echo "  --full --yes 删除配置和站点文件 (跳过确认)"
                echo "  --backup     备份后删除全部"
                echo "  (无选项)     仅删除配置 (需确认)"
            else
                local mode="config"
                local skip_confirm=""
                case "$3" in
                    --config) mode="config";;
                    --full) mode="full"; [ "$4" = "--yes" ] && skip_confirm="--yes";;
                    --backup) mode="backup";;
                    --yes) mode="config";;  # 仅 --yes 时默认 config 模式
                    "")
                        # 无选项时交互确认后删除配置
                        validate_domain "$2" || exit 1
                        [ ! -f "$NGINX_CONF_DIR/$2" ] && echo -e "${RED}站点不存在${NC}" && exit 1
                        read -p "确认删除 $2 的配置? (y/n): " c
                        [ "$c" != "y" ] && echo "已取消" && exit 0
                        mode="config"
                        ;;
                    *)
                        echo -e "${RED}无效选项: $3${NC}"
                        exit 1
                        ;;
                esac
                _do_site_delete "$2" "$mode" "$skip_confirm" || exit 1
            fi
            ;;
        enable) [ -n "$2" ] && site_enable "$2" || echo "用法: site enable <域名>";;
        disable) [ -n "$2" ] && site_disable "$2" || echo "用法: site disable <域名>";;
        info) [ -n "$2" ] && site_info "$2" || echo "用法: site info <域名>";;
        rewrite)
            if [ -z "$2" ]; then
                list_rewrite_rules
            elif [ -z "$3" ]; then
                rewrite_menu "$2"
            else
                set_site_rewrite "$2" "$3"
            fi
            ;;
        ssl) source /opt/site_manager/lib/ssl.sh 2>/dev/null || source "$SCRIPT_DIR/../lib/ssl.sh"
            case "$2" in
                account)
                    case "$3" in
                        list|ls|"") ssl_account_list;;
                        add) ssl_account_add "$4";;
                        remove|rm) ssl_account_remove "$4";;
                        *) echo "用法: site ssl account <list|add|remove> [别名]";;
                    esac;;
                bind) ssl_bind "$3" "$4";;
                unbind) ssl_unbind "$3";;
                bindlist) ssl_bindlist;;
                list|ls) ssl_list;;
                config) ssl_dns_config "$3" "$4";;
                install) ssl_install;;
                renew) ssl_renew;;
                "")
                    echo "用法:"
                    echo "  site ssl <域名> [--dns] [--wildcard]  申请证书"
                    echo "  site ssl \"a.com,b.com\" --dns         多域名证书"
                    echo ""
                    echo "账号管理:"
                    echo "  site ssl account list               查看账号"
                    echo "  site ssl account add <别名>         添加账号"
                    echo "  site ssl account remove <别名>      删除账号"
                    echo ""
                    echo "域名绑定:"
                    echo "  site ssl bind <域名> <账号别名>      绑定域名到账号"
                    echo "  site ssl unbind <域名>              解绑域名"
                    echo "  site ssl bindlist                   查看绑定关系"
                    echo ""
                    echo "其他:"
                    echo "  site ssl list                       查看证书状态"
                    echo "  site ssl renew                      续期证书(>30天跳过)"
                    echo "  site ssl config                     配置默认DNS账号"
                    ;;
                *) ssl_request "$2" "${@:3}";;
            esac;;
        backup)
            case "$2" in
                site|db|path|all)
                    # 统一调用 backup_cron.sh，内置包装器日志
                    /opt/site_manager/bin/backup_cron.sh "$2" "$3" "$4"
                    ;;
                list)
                    list_backups
                    ;;
                config)
                    local conf="/opt/site_manager/config/backup.conf"
                    case "$3" in
                        "")
                            echo -e "${CYAN}======== 备份配置 ========${NC}"
                            echo ""
                            echo -e "${YELLOW}保留份数:${NC}"
                            echo "  数据库: $DB_KEEP 份"
                            echo "  站点:   $SITE_KEEP 份"
                            echo "  路径:   ${PATH_KEEP:-7} 份"
                            echo ""
                            echo -e "${YELLOW}FTP 配置:${NC}"
                            if [ "$FTP_ENABLED" = "true" ]; then
                                echo "  状态: ${GREEN}已启用${NC}"
                                echo "  主机: $FTP_HOST:$FTP_PORT"
                                echo "  用户: $FTP_USER"
                                echo "  路径: $FTP_PATH"
                                echo "  上传后删除本地: $FTP_DELETE_LOCAL"
                            else
                                echo "  状态: ${RED}未启用${NC}"
                            fi
                            echo ""
                            echo "修改配置: $conf"
                            ;;
                        ftp)
                            if [ "$4" = "on" ]; then
                                sed -i 's/^FTP_ENABLED=.*/FTP_ENABLED=true/' "$conf"
                                echo -e "${GREEN}FTP 备份已启用${NC}"
                            elif [ "$4" = "off" ]; then
                                sed -i 's/^FTP_ENABLED=.*/FTP_ENABLED=false/' "$conf"
                                echo -e "${YELLOW}FTP 备份已禁用${NC}"
                            else
                                echo "用法: site backup config ftp <on|off>"
                            fi
                            ;;
                        keep)
                            if [ -n "$4" ] && [ -n "$5" ]; then
                                case "$4" in
                                    db) sed -i "s/^DB_KEEP=.*/DB_KEEP=$5/" "$conf"; echo "数据库保留: $5 份";;
                                    site) sed -i "s/^SITE_KEEP=.*/SITE_KEEP=$5/" "$conf"; echo "站点保留: $5 份";;
                                    path) sed -i "s/^PATH_KEEP=.*/PATH_KEEP=$5/" "$conf"; echo "路径保留: $5 份";;
                                    *) echo "类型: db, site, path";;
                                esac
                            else
                                echo "用法: site backup config keep <db|site|path> <份数>"
                            fi
                            ;;
                        *)
                            echo "用法:"
                            echo "  site backup config              查看配置"
                            echo "  site backup config ftp <on|off> 启用/禁用FTP"
                            echo "  site backup config keep <类型> <份数>  设置保留份数"
                            ;;
                    esac
                    ;;
                *)
                    echo "用法:"
                    echo "  site backup site [域名]   备份站点 (不指定则备份全部)"
                    echo "  site backup db [库名]     备份数据库 (不指定则备份全部)"
                    echo "  site backup path <路径>   备份指定目录"
                    echo "  site backup list          查看备份列表"
                    echo "  site backup config        查看/修改备份配置"
                    ;;
            esac
            ;;
        restore)
            if [ -z "$2" ] || [ -z "$3" ]; then
                echo "用法: site restore <域名> <备份文件>"
            elif [ ! -f "$3" ]; then
                echo -e "${RED}备份文件不存在: $3${NC}"
                exit 1
            else
                if tar -xzf "$3" -C "$SITES_DIR" 2>/dev/null; then
                    chown -R www:www "$SITES_DIR/$2" 2>/dev/null
                    echo -e "${GREEN}恢复成功${NC}"
                else
                    echo -e "${RED}恢复失败${NC}"
                    exit 1
                fi
            fi
            ;;
        db) source /opt/site_manager/lib/db.sh; case "$2" in
                create) db_create "$3";;
                drop) db_drop "$3";;
                import) db_import "$3" "$4";;
                export) db_export "$3";;
                list) db_list;;
                restore) if [ -n "$3" ] && [ -n "$4" ] && [ -f "$4" ]; then mysql_exec "$3" < "$4" && echo "恢复成功" || echo -e "${RED}恢复失败${NC}"; else echo "用法: site db restore <库> <文件>"; fi;;
                *) echo "用法: site db <create|drop|import|export|list|restore>"; echo "备份请使用: site backup db [库名]";;
            esac;;
        nginx) case "$2" in
            reload) systemctl reload nginx && echo -e "${GREEN}Nginx 已重载${NC}" || echo -e "${RED}Nginx 重载失败${NC}";;
            restart) systemctl restart nginx && echo -e "${GREEN}Nginx 已重启${NC}" || echo -e "${RED}Nginx 重启失败${NC}";;
            status) systemctl status nginx --no-pager;;
            *) systemctl reload nginx && echo -e "${GREEN}Nginx 已重载${NC}" || echo -e "${RED}Nginx 重载失败${NC}";;
            esac;;
        php) case "$2" in
            restart) for v in 7.4 8.0 8.1 8.2 8.3; do systemctl restart "php${v}-fpm" 2>/dev/null && echo -e "${GREEN}PHP $v FPM 已重启${NC}"; done;;
            status) for v in 7.4 8.0 8.1 8.2 8.3; do systemctl is-active "php${v}-fpm" 2>/dev/null | grep -q active && echo "PHP $v FPM: 运行中"; done;;
            *) php -v;;
            esac;;
        mysql) case "$2" in
            restart) systemctl restart mysql && echo -e "${GREEN}MySQL 已重启${NC}" || systemctl restart mariadb && echo -e "${GREEN}MariaDB 已重启${NC}" || echo -e "${RED}数据库重启失败${NC}";;
            status) systemctl status mysql --no-pager 2>/dev/null || systemctl status mariadb --no-pager;;
            *) systemctl status mysql --no-pager 2>/dev/null || systemctl status mariadb --no-pager;;
            esac;;
        redis) case "$2" in
            restart) systemctl restart redis-server && echo -e "${GREEN}Redis 已重启${NC}" || echo -e "${RED}Redis 重启失败${NC}";;
            *) systemctl status redis-server --no-pager;;
            esac;;
        supervisor|sv)
            if ! command -v supervisorctl &>/dev/null; then
                echo -e "${RED}Supervisor 未安装${NC}"
                echo "安装: apt install supervisor"
                exit 1
            fi
            case "$2" in
                status|"") supervisorctl status;;
                start) [ -n "$3" ] && supervisorctl start "$3" || echo "用法: site supervisor start <app|all>";;
                stop) [ -n "$3" ] && supervisorctl stop "$3" || echo "用法: site supervisor stop <app|all>";;
                restart) [ -n "$3" ] && supervisorctl restart "$3" || echo "用法: site supervisor restart <app|all>";;
                reload|reread) supervisorctl reread && supervisorctl update && echo -e "${GREEN}Supervisor 配置已重载${NC}";;
                tail) [ -n "$3" ] && supervisorctl tail -f "$3" || echo "用法: site supervisor tail <app>";;
                update) supervisorctl update;;
                add)
                    if [ -n "$3" ] && [ -n "$4" ]; then
                        local app_name="$3"
                        local app_cmd="$4"
                        local app_dir="${5:-$(pwd)}"
                        local app_user="${6:-root}"
                        local conf_dir="${SUPERVISOR_CONF_DIR:-/etc/supervisor/conf.d}"

                        # 自动解析命令中第一个词的完整路径
                        local first_cmd=$(echo "$app_cmd" | awk '{print $1}')
                        local full_path=$(which "$first_cmd" 2>/dev/null)
                        if [ -n "$full_path" ] && [ "$full_path" != "$first_cmd" ]; then
                            app_cmd="${app_cmd/$first_cmd/$full_path}"
                        fi

                        mkdir -p "$conf_dir"
                        cat > "${conf_dir}/${app_name}.conf" << SUPCONF
[program:${app_name}]
command=${app_cmd}
directory=${app_dir}
autostart=true
autorestart=true
stderr_logfile=/var/log/supervisor/${app_name}.err.log
stdout_logfile=/var/log/supervisor/${app_name}.out.log
user=${app_user}
SUPCONF
                        supervisorctl reread && supervisorctl update
                        echo -e "${GREEN}已添加: ${app_name}${NC}"
                        echo -e "${CYAN}配置: ${conf_dir}/${app_name}.conf${NC}"
                    else
                        echo "用法: site supervisor add <名称> <命令> [目录] [用户]"
                    fi
                    ;;
                remove|rm)
                    if [ -n "$3" ]; then
                        local conf_dir="${SUPERVISOR_CONF_DIR:-/etc/supervisor/conf.d}"
                        supervisorctl stop "$3" 2>/dev/null
                        rm -f "${conf_dir}/${3}.conf"
                        supervisorctl reread && supervisorctl update
                        echo -e "${GREEN}已移除: $3${NC}"
                    else
                        echo "用法: site supervisor remove <app>"
                    fi
                    ;;
                fix)
                    # 修复 supervisord.conf 中多个 [include] 块的问题
                    local conf="/etc/supervisor/supervisord.conf"
                    if [ -f "$conf" ]; then
                        local include_count=$(grep -c '^\[include\]' "$conf")
                        if [ "$include_count" -gt 1 ]; then
                            echo -e "${YELLOW}发现 $include_count 个 [include] 块，正在合并...${NC}"
                            # 提取所有 files 行并合并
                            local all_files=$(grep '^files' "$conf" | sed 's/files\s*=\s*//' | tr '\n' ' ')
                            # 删除所有 [include] 块
                            sed -i '/^\[include\]/,/^files/d' "$conf"
                            # 添加合并后的 [include] 块
                            echo -e "\n[include]\nfiles = $all_files" >> "$conf"
                            echo -e "${GREEN}已合并为单个 [include] 块${NC}"
                            supervisorctl reread && supervisorctl update
                        else
                            echo -e "${GREEN}supervisord.conf 配置正常${NC}"
                        fi
                    else
                        echo -e "${RED}未找到 $conf${NC}"
                    fi
                    ;;
                *)
                    # 透传其他命令给 supervisorctl
                    if [ -n "$2" ]; then
                        supervisorctl "${@:2}"
                    else
                        echo "用法: site supervisor <命令> [参数]"
                        echo "常用: status|start|stop|restart|reload|tail|add|remove|fix"
                        echo "其他命令直接透传给 supervisorctl"
                    fi
                    ;;
            esac;;
        cron)
            local cron_log="/www/wwwlogs/site_manager/cron.log"
            local wrapper="/opt/site_manager/scripts/cron_wrapper.sh"
            case "$2" in
                list|ls|"")
                    echo -e "${CYAN}======== 计划任务列表 ========${NC}"
                    crontab -l 2>/dev/null | grep -v '^#' | grep -v '^$' | nl -ba
                    ;;
                add)
                    if [ -n "$3" ] && [ -n "$4" ]; then
                        local schedule="$3"
                        local cmd="$4"
                        # site 内置命令不需要包装器（已内置日志），但需要完整路径
                        if [[ "$cmd" == "site backup"* ]] || [[ "$cmd" == "site ssl renew"* ]]; then
                            # cron 环境 PATH 不含 /usr/local/bin，需使用完整路径
                            local full_cmd="${cmd/site//usr/local/bin/site}"
                        else
                            # 其他命令使用 site cron run 包装（自动生成日志路径）
                            local full_cmd="/usr/local/bin/site cron run \"$cmd\""
                        fi
                        # 添加到 crontab
                        (crontab -l 2>/dev/null; echo "$schedule $full_cmd") | crontab -
                        echo -e "${GREEN}已添加计划任务:${NC}"
                        echo "  时间: $schedule"
                        echo "  命令: $full_cmd"
                    else
                        echo "用法: site cron add \"<时间>\" \"<命令>\""
                        echo ""
                        echo "日志自动保存到 /www/wwwlogs/cron/{站点}_{命令}.log"
                        echo ""
                        echo "示例:"
                        echo "  site cron add \"0 * * * *\" \"site backup db\""
                        echo "  site cron add \"*/5 * * * *\" \"php /www/wwwroot/xxx/artisan schedule:run\""
                    fi
                    ;;
                remove|rm)
                    if [ -n "$3" ]; then
                        local line_num="$3"
                        local total=$(crontab -l 2>/dev/null | grep -v '^#' | grep -v '^$' | wc -l)
                        if [ "$line_num" -gt 0 ] && [ "$line_num" -le "$total" ]; then
                            # 获取要删除的行内容
                            local to_delete=$(crontab -l 2>/dev/null | grep -v '^#' | grep -v '^$' | sed -n "${line_num}p")
                            # 从 crontab 中删除该行
                            crontab -l 2>/dev/null | grep -v "^${to_delete}$" | crontab -
                            echo -e "${GREEN}已删除: $to_delete${NC}"
                        else
                            echo -e "${RED}无效编号: $line_num (共 $total 条)${NC}"
                        fi
                    else
                        echo "用法: site cron remove <编号>"
                        echo "先用 site cron list 查看编号"
                    fi
                    ;;
                log)
                    local lines="${3:-50}"
                    if [ -f "$cron_log" ]; then
                        echo -e "${CYAN}======== 计划任务日志 (最近 $lines 行) ========${NC}"
                        tail -n "$lines" "$cron_log"
                    else
                        echo -e "${YELLOW}日志文件不存在: $cron_log${NC}"
                    fi
                    ;;
                run)
                    # 用包装器执行命令（供 crontab 调用）
                    if [ -n "$3" ]; then
                        "$wrapper" "$3" "$4"
                    else
                        echo "用法: site cron run \"<命令>\" [日志文件]"
                    fi
                    ;;
                *)
                    echo "用法:"
                    echo "  site cron list              查看计划任务"
                    echo "  site cron add \"<时间>\" \"<命令>\"  添加任务"
                    echo "  site cron remove <编号>     删除任务"
                    echo "  site cron log [行数]        查看日志"
                    echo "  site cron run \"<命令>\"     用包装器执行"
                    ;;
            esac;;
        firewall) case "$2" in
                status) ufw status numbered;;
                on) ufw --force enable;;
                off) ufw disable;;
                allow) [ -n "$3" ] && ufw allow "$3/tcp";;
                deny) [ -n "$3" ] && ufw deny "$3/tcp";;
                *) ufw status;;
            esac;;
        soft) soft_list;;
        install) [ -n "$2" ] && { local script="${2}.sh"; [ -f "$SOFTWARE_DIR/install/$script" ] && bash "$SOFTWARE_DIR/install/$script" install "$3" || echo "未知软件: $2"; } || echo "用法: site install <软件> [版本]";;
        uninstall) [ -n "$2" ] && { local script="${2}.sh"; [ -f "$SOFTWARE_DIR/install/$script" ] && bash "$SOFTWARE_DIR/install/$script" uninstall "$3" || echo "未知软件: $2"; } || echo "用法: site uninstall <软件> [版本]";;
        panel) case "$2" in start)panel_start;; stop)panel_stop;; restart)panel_stop;sleep 1;panel_start;; *)panel_menu;; esac;;
        help|--help|-h) show_help;;
        *) show_help;;
    esac
}

# ================== 交互式菜单 ==================
interactive_menu() {
    while true; do
        show_menu
        read -p "选项: " c
        case "$c" in
            1) site_menu;;
            2) software_menu;;
            3) backup_menu;;
            4) security_menu;;
            5) system_menu;;
            6) panel_menu;;
            0|q) exit 0;;
            *) echo -e "${RED}无效选项${NC}";;
        esac
        echo ""
        read -p "按回车继续..."
    done
}

# ================== 主入口 ==================
main() {
    [ "$EUID" -ne 0 ] && echo "请用 root 权限运行" && exit 1

    if [ $# -eq 0 ]; then
        show_help
    else
        case "$1" in
            -m|menu) interactive_menu;;
            *) handle_cli "$@";;
        esac
    fi
}

main "$@"
